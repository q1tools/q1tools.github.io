<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=0.1, minimum-scale=0.1, maximum-scale=5, user-scalable=yes">
    <title>PAK File Tool</title>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/tga-js@1.1.1/dist/umd/tga.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.4/howler.js"></script>
    <script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/3.3.0/model-viewer.min.js"></script>
    <!-- QuakeWebTools https://github.com/andyp123/quake_web_tools -->
    <!--lib-->
    <script src="QuakeWebTools/scripts/lib/stats.min.js"></script>
    <script src="QuakeWebTools/scripts/lib/DataStream.js"></script>
    <script src="QuakeWebTools/scripts/lib/three.js"></script>
    <script src="QuakeWebTools/scripts/lib/orbitcontrols.js"></script>
    <script src="QuakeWebTools/scripts/lib/firstpersoncontrols.js"></script>
    <!--util-->
    <script src="QuakeWebTools/scripts/util/filemanager.js"></script>
    <script src="QuakeWebTools/scripts/util/fileutil.js"></script>
    <script src="QuakeWebTools/scripts/util/imageutil.js"></script>
    <!--types-->
    <script src="QuakeWebTools/scripts/types/pak.js"></script>
    <script src="QuakeWebTools/scripts/types/wad.js"></script>
    <script src="QuakeWebTools/scripts/types/pal.js"></script>
    <script src="QuakeWebTools/scripts/types/lmp.js"></script>
    <script src="QuakeWebTools/scripts/types/spr.js"></script>
    <script src="QuakeWebTools/scripts/types/bsp.js"></script>
    <script src="QuakeWebTools/scripts/types/mdl.js"></script>
    <!--application-->
    <script src="QuakeWebTools/scripts/quakewebtools.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.129.0/build/three.module.js",
                "three/examples/jsm/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.129.0/examples/jsm/controls/OrbitControls.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

        class MD3Loader {
            constructor(manager) {
                this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
                this.scale = 1;
            }

            load(url, onLoad, onProgress, onError) {
                const loader = new THREE.FileLoader(this.manager);
                loader.setResponseType('arraybuffer');
                loader.load(url, (buffer) => {
                    onLoad(this.parse(buffer));
                }, onProgress, onError);
            }

            parse(buffer) {
                const data = new DataView(buffer);
                const header = this.parseHeader(data);

                if (header.ident !== 'IDP3') {
                    console.error('MD3Loader: Not a valid MD3 file.');
                    return null;
                }

                const geometry = new THREE.BufferGeometry();
                const material = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    transparent: false,
                    opacity: 1,
                    alphaTest: 0.5,
                    depthWrite: true,
                    depthTest: true,
                    side: THREE.DoubleSide,
                    blending: THREE.NoBlending
                });
                const vertices = [];
                const normals = [];
                const uvs = [];
                const indices = [];
                const shaderNames = new Set();

                this.parseFrames(data, header);
                this.parseTags(data, header);
                this.parseSurfaces(data, header, vertices, normals, uvs, indices, shaderNames);

                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
                geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
                geometry.setIndex(indices);

                geometry.computeVertexNormals();
                geometry.computeBoundingBox();

                const mesh = new THREE.Mesh(geometry, material);
                if (!mesh.userData) {
                    mesh.userData = {};
                }
                mesh.userData.shaderNames = Array.from(shaderNames);
                return mesh;
            }

            parseHeader(data) {
                return {
                    ident: this.readString(data, 0, 4),
                    version: data.getInt32(4, true),
                    name: this.readString(data, 8, 64),
                    flags: data.getInt32(72, true),
                    numFrames: data.getInt32(76, true),
                    numTags: data.getInt32(80, true),
                    numSurfaces: data.getInt32(84, true),
                    numSkins: data.getInt32(88, true),
                    ofsFrames: data.getInt32(92, true),
                    ofsTags: data.getInt32(96, true),
                    ofsSurfaces: data.getInt32(100, true),
                    ofsEnd: data.getInt32(104, true)
                };
            }

            parseFrames(data, header) {
                const frames = [];
                let offset = header.ofsFrames;

                for (let i = 0; i < header.numFrames; i++) {
                    const frame = {
                        minBounds: this.readVector3(data, offset),
                        maxBounds: this.readVector3(data, offset + 12),
                        localOrigin: this.readVector3(data, offset + 24),
                        radius: data.getFloat32(offset + 36, true),
                        name: this.readString(data, offset + 40, 16)
                    };
                    frames.push(frame);
                    offset += 56;
                }

                return frames;
            }

            parseTags(data, header) {
                const tags = [];
                let offset = header.ofsTags;

                for (let i = 0; i < header.numTags * header.numFrames; i++) {
                    const tag = {
                        name: this.readString(data, offset, 64),
                        origin: this.readVector3(data, offset + 64),
                        axis: [
                            this.readVector3(data, offset + 76),
                            this.readVector3(data, offset + 88),
                            this.readVector3(data, offset + 100)
                        ]
                    };
                    tags.push(tag);
                    offset += 112;
                }

                return tags;
            }

            parseSurfaces(data, header, vertices, normals, uvs, indices, shaderNames) {
                let offset = header.ofsSurfaces;

                for (let i = 0; i < header.numSurfaces; i++) {
                    const surfaceHeader = this.parseSurfaceHeader(data, offset);

                    this.parseSurfaceTriangles(data, surfaceHeader, indices, offset);
                    this.parseSurfaceUVs(data, surfaceHeader, uvs, offset);
                    this.parseSurfaceVertices(data, surfaceHeader, vertices, normals, offset);
                    this.parseSurfaceShaders(data, surfaceHeader, shaderNames, offset);

                    offset += surfaceHeader.ofsEnd;
                }
            }

            parseSurfaceHeader(data, offset) {
                return {
                    ident: this.readString(data, offset, 4),
                    name: this.readString(data, offset + 4, 64),
                    flags: data.getInt32(offset + 68, true),
                    numFrames: data.getInt32(offset + 72, true),
                    numShaders: data.getInt32(offset + 76, true),
                    numVerts: data.getInt32(offset + 80, true),
                    numTriangles: data.getInt32(offset + 84, true),
                    ofsTriangles: data.getInt32(offset + 88, true),
                    ofsShaders: data.getInt32(offset + 92, true),
                    ofsSt: data.getInt32(offset + 96, true),
                    ofsXyzNormal: data.getInt32(offset + 100, true),
                    ofsEnd: data.getInt32(offset + 104, true)
                };
            }

            parseSurfaceTriangles(data, surfaceHeader, indices, offset) {
                let triangleOffset = offset + surfaceHeader.ofsTriangles;

                for (let i = 0; i < surfaceHeader.numTriangles; i++) {
                    indices.push(
                        data.getInt32(triangleOffset, true),
                        data.getInt32(triangleOffset + 4, true),
                        data.getInt32(triangleOffset + 8, true)
                    );
                    triangleOffset += 12;
                }
            }

            parseSurfaceUVs(data, surfaceHeader, uvs, offset) {
                let uvOffset = offset + surfaceHeader.ofsSt;

                for (let i = 0; i < surfaceHeader.numVerts; i++) {
                    uvs.push(
                        data.getFloat32(uvOffset, true),
                        data.getFloat32(uvOffset + 4, true)
                    );
                    uvOffset += 8;
                }
            }

            parseSurfaceVertices(data, surfaceHeader, vertices, normals, offset) {
                let vertexOffset = offset + surfaceHeader.ofsXyzNormal;

                for (let i = 0; i < surfaceHeader.numVerts * surfaceHeader.numFrames; i++) {
                    vertices.push(
                        data.getInt16(vertexOffset, true) * this.scale,
                        data.getInt16(vertexOffset + 2, true) * this.scale,
                        data.getInt16(vertexOffset + 4, true) * this.scale
                    );

                    const normal = data.getInt16(vertexOffset + 6, true);
                    normals.push(...this.decodeNormal(normal));

                    vertexOffset += 8;
                }
            }

            parseSurfaceShaders(data, surfaceHeader, shaderNames, offset) {
                if (!shaderNames || !surfaceHeader.numShaders) {
                    return;
                }

                let shaderOffset = offset + surfaceHeader.ofsShaders;
                for (let i = 0; i < surfaceHeader.numShaders; i++) {
                    const name = this.readString(data, shaderOffset, 64).trim();
                    if (name) {
                        shaderNames.add(name);
                    }
                    shaderOffset += 68;
                }
            }

            decodeNormal(normal) {
                const lat = (normal >> 8) & 0xff;
                const lng = normal & 0xff;

                const latRad = lat * Math.PI / 128;
                const lngRad = lng * Math.PI / 128;

                const x = Math.cos(latRad) * Math.sin(lngRad);
                const y = Math.sin(latRad) * Math.sin(lngRad);
                const z = Math.cos(lngRad);

                return [x, y, z];
            }

            readString(data, offset, length) {
                let str = '';
                for (let i = 0; i < length; i++) {
                    const char = data.getUint8(offset + i);
                    if (char === 0) break;
                    str += String.fromCharCode(char);
                }
                return str;
            }

            readVector3(data, offset) {
                return [
                    data.getFloat32(offset, true),
                    data.getFloat32(offset + 4, true),
                    data.getFloat32(offset + 8, true)
                ];
            }
        }

        const support = { THREE, OrbitControls, MD3Loader };
        window.Q1ToolsMD3Support = support;
        window.Q1ToolsMD3SupportReady = Promise.resolve(support);
        window.dispatchEvent(new CustomEvent('md3previewready', { detail: support }));
    </script>
</head>

<body onload="app_init()"> <!--app_init() for QWT -->
    <h1 class="header-container"><img src="pak.png" class="header-image" alt="PAK File Tool Logo">PAK File Tool</h1>

    <!-- File Drop Zone for Viewing PAK/PK3 files -->
    <div id="pak_view_drop">
        <span id="viewing-text"><span class="text-color-view-create">View / Convert</span>: Drag and drop a .pak or .pk3 here or
            click to select</span>
        <input type="file" id="packfile" accept=".pak,.pk3" onchange="pakSelector(this.files)" />
        <div id="loadingCircle" class="loading-circle" style="display: none;"></div>
    </div>

    <!-- File Drop Zone for PAK creation -->
    <div id="create_drop">
        <span class="text-color-view-create">Create</span>: Drag and drop a folder here or click to select a folder
        <input type="file" id="pakcreator" webkitdirectory onchange="createPakHelper(this.files)" />
    </div>

    <!-- Progress Bar Wrapper For Download / Convert to .zip from .pak -->
    <div id="progressWrapper">
        <div id="progressBar"></div>
    </div>

    <!-- Download All Button -->
    <button id="downloadAll">Download All as Zip</button>

    <!-- Display PAK File Contents -->
    <div id="packfilecontents"></div>

    <!-- Modal for Confirming PAK Creation -->
    <div id="myModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <p>New .pak created and download initiated!</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.6.0/jszip.min.js"></script>
    <script>
        let fileBlobs = [];
        let currentPakFileName = ''; // This will store the name of the current PAK file
        let viewFileBlobs = [];
        let filePathMap = new Map(); // Key: File object, Value: Path string


        function createPAK(files) {
            // Filter out .DS_Store and other system files if needed
            files = files.filter(file => !file.name.startsWith('.'));

            // Define the magic number "PACK" for the PAK file header
            const magicNumber = "PACK";
            let dirOffset = 12; // Initial offset after the header, accounting for the header size
            let dirSize = 0; // The size of the directory, will be computed based on entries

            // Arrays to hold the directory entries and corresponding file data
            let directoryEntries = [];
            let fileData = [];

            // Process each file to create directory entries and collect file data
            files.forEach(file => {
                let fullPath;

                // Check if 'customPath' is available, fallback to 'webkitRelativePath' or file.name
                if (file.customPath) {
                    fullPath = file.customPath;
                } else if (file.webkitRelativePath) {
                    // Remove the top-level folder name from the path
                    let pathSegments = file.webkitRelativePath.split('/');
                    pathSegments.shift(); // Remove the first segment (top-level folder name)
                    fullPath = pathSegments.join('/');
                } else {
                    fullPath = file.name; // Default to just the file name
                }

                let filenamePadded = fullPath.padEnd(56, '\0'); // Pad the filename for alignment

                let fileEntry = {
                    filename: filenamePadded,
                    offset: dirOffset,
                    size: file.size
                };
                directoryEntries.push(fileEntry);

                // Update the directory offset for the next file based on current file size
                dirOffset += file.size;

                // Add the file's data to the fileData array as a Blob
                fileData.push(new Blob([file], { type: 'application/octet-stream' }));
            });

            // Calculate the total size of the directory, assuming each entry is 64 bytes
            dirSize = directoryEntries.length * 64;

            // Construct the directory part of the PAK file
            let directoryBlobParts = directoryEntries.flatMap(entry => [
                entry.filename,
                new Uint32Array([entry.offset]),
                new Uint32Array([entry.size])
            ]);
            let directoryBlob = new Blob(directoryBlobParts, { type: 'application/octet-stream' });

            // Construct the header part of the PAK file with the magic number, directory offset, and directory size
            let headerBlob = new Blob([magicNumber, new Uint32Array([dirOffset]), new Uint32Array([dirSize])], { type: 'application/octet-stream' });

            // Combine the header, file data, and directory into one Blob to form the complete PAK file
            return new Blob([headerBlob, ...fileData, directoryBlob], { type: 'application/octet-stream' });
        }

        function showModal(pakFileName, totalFiles, totalSize) {
            // Format the total size of the files for display
            const formattedTotalSize = formatFileSize(totalSize);

            var modal = document.getElementById("myModal");

            var closeButton = document.getElementsByClassName("close")[0];

            var modalContent = modal.querySelector('.modal-content p');
            modalContent.textContent = `New PAK file "${pakFileName}" with ${totalFiles} file(s) created, total size: ${formattedTotalSize}. Download initiated!`;

            closeButton.onclick = function () {
                modal.style.display = "none";
            };

            window.onclick = function (event) {
                if (event.target === modal) {
                    modal.style.display = "none";
                }
            };

            modal.style.display = "block";
        }

        function resetGlobalState() {
            fileBlobs = [];
        }

        function clearFileInput(inputId) {
            const fileInput = document.getElementById(inputId);
            fileInput.value = ''; // This will clear the current selection
        }

        function createPakHelper(files, folderName) {
            // Exit the function early if no files were selected
            if (!files.length) {
                alert('No files were selected.');
                return;
            }

            // safari lets me select single file, disallow
            //  var folderPath = files[0].webkitRelativePath;
            //  var folderName = folderPath.split('/')[0]; // Get the first segment of the path
            // if (!folderName)
            //     alert('Please select a folder');

            // Extract the folder name from the files if not provided
            if (!folderName && files[0].webkitRelativePath) {
                folderName = files[0].webkitRelativePath.split('/')[0];
            }

            // Exit the function if the folder name could not be determined
            if (!folderName) {
                console.error('No folder name provided and unable to determine from files.');
                return;
            }

            // Collect all files from the selected folder into an array
            let folderFiles = Array.from(files);

            // Process the files to create a .pak file using a hypothetical createPAK function
            let pakFileBlob = createPAK(folderFiles);

            // Calculate the total size and number of files
            let totalSize = folderFiles.reduce((acc, file) => acc + file.size, 0);
            let totalFiles = folderFiles.length;
            let pakFileName = `${folderName}.pak`;

            // Initiate the download of the .pak file
            let downloadLink = URL.createObjectURL(pakFileBlob);
            let downloadAnchor = document.createElement('a');
            downloadAnchor.href = downloadLink;
            downloadAnchor.download = pakFileName;
            document.body.appendChild(downloadAnchor);
            downloadAnchor.click();
            document.body.removeChild(downloadAnchor);

            // Clean up by revoking the object URL
            URL.revokeObjectURL(downloadLink);

            // Show the download modal with details about the .pak file
            showModal(pakFileName, totalFiles, totalSize);


            resetGlobalState();

            clearFileInput('packfile'); // Assuming 'packfile' is the ID of your file input
            clearFileInput('pakcreator'); // Assuming 'pakcreator' is the ID of your folder input
        }

        // Handles the selection of a file and prepares it for processing
        function pakSelector(files) {
            if (files.length === 0) {
                return;
            }

            // Extract the base name of the first selected file
            var fileName = files[0].name;

            // Update the text content of the viewing-text span
            document.getElementById('viewing-text').innerHTML = '<span class="text-color-view-create">Viewing:</span> ' + fileName;

            // Extract the base name of the first selected file, stripping the extension
            viewCurrentPakFileName = files[0].name.replace(/\..+$/, '');

            // Pass the file to a function that reads and processes the PAK file
            readPackFile(files[0]);
        }

        // Converts a file size in bytes to a human-readable format
        function formatFileSize(bytes) {
            const KB = 1024;
            const MB = KB * KB;
            const GB = MB * KB;

            if (bytes >= GB) {
                return (bytes / GB).toFixed(2) + ' GB'; // Size in GB with two decimal places
            } else if (bytes >= MB) {
                return (bytes / MB).toFixed(2) + ' MB'; // Size in MB with two decimal places
            } else {
                return (bytes / KB).toFixed(2) + ' KB'; // Size in KB with two decimal places
            }
        }


        function readBSPFile(file) {
            let reader = new FileReader();
            reader.onload = function (e) {
                let arrayBuffer = e.target.result;
                let dataView = new DataView(arrayBuffer);

                // Read the BSP header and directory entries
                let version = dataView.getInt32(0, true); // Assuming little-endian format
                let entitiesOffset = dataView.getInt32(4, true);
                let entitiesSize = dataView.getInt32(8, true);

                // Extract entities lump data as a Blob
                let blob = new Blob([arrayBuffer.slice(entitiesOffset, entitiesOffset + entitiesSize)]);

                // Create a new FileReader to read the Blob as text
                let textReader = new FileReader();
                textReader.onload = function (e) {
                    let entitiesData = e.target.result;

                    // Parse entities lump to find worldspawn
                    let worldspawnData = parseWorldspawn(entitiesData);

                    // Update the web page to display the worldspawn data
                    displayWorldspawnData(worldspawnData);
                };

                // Read the blob as a text assuming basic ASCII characters
                textReader.readAsText(blob);
            };

            reader.readAsArrayBuffer(file);
        }

        function extractEntitiesData(arrayBuffer) {
            let dataView = new DataView(arrayBuffer);

            // Read the offset and size of the entities lump from the BSP header
            // The entities lump is the first entry in the directory, so its offset and size are at bytes 4 and 8
            let entitiesOffset = dataView.getInt32(4, true); // true for little-endian
            let entitiesSize = dataView.getInt32(8, true);

            // Extract the entities data as a string
            let entitiesData = '';
            for (let i = 0; i < entitiesSize; i++) {
                let charCode = dataView.getUint8(entitiesOffset + i);
                entitiesData += String.fromCharCode(charCode);
            }

            return entitiesData;
        }

        function parseWorldspawn(entitiesData) {
            // Find the start of any block
            let blockStart = entitiesData.indexOf('{');
            while (blockStart !== -1) {
                // Find the end of the current block
                let blockEnd = entitiesData.indexOf('}', blockStart);
                if (blockEnd === -1) return null; // Unclosed block

                // Extract the block
                let block = entitiesData.substring(blockStart, blockEnd + 1);

                // Check if it's the worldspawn block
                if (block.includes('"classname" "worldspawn"')) {
                    // Extract the message from the worldspawn block
                    let messageMatch = /"message"\s+"([^"]+)"/.exec(block);
                    if (messageMatch) {
                        // Translate the message using the translateName function
                        let translatedMessage = translateName(messageMatch[1]);
                        return { message: translatedMessage };
                    } else {
                        return null;
                    }
                }

                // Move to the next block
                blockStart = entitiesData.indexOf('{', blockEnd + 1);
            }

            return null; // Worldspawn block not found
        }

        // dequake unicode in worldspawn map description name
        function translateName(name) {
            var translatedName = '';

            for (var i = 0; i < name.length; i++) {
                var character = name.charAt(i);
                var quakeChar = deQuakeMap[character];

                console.log(`Original character: ${character}`);

                if (quakeChar !== undefined) {
                    console.log(`Mapped character: ${quakeChar}`);
                    translatedName += quakeChar;
                } else {
                    console.log(`Character not in deQuakeMap: ${character}`);
                    translatedName += character;
                }
            }

            console.log(`Translated name: ${translatedName}`);
            return translatedName;
        }

        // dequake for readable previews uses javascript escape chars
        deQuakeMap = {
            '\u001c': '&#183;', '\u0001': '0', '\u0002': '0', '\u0003': '0', '\u201e': '0', '\u0005': '&#183;', '\u2020': '0', '\u2021': '0', '\u02c6': '0', '\u2030': '0', 'normal space disabled': ' ', '\u000B': '#', '\u000c': ' ', '> disabled': '&#187;', '\u000e': '&#183;', '\u000f': '&#183;',
            '\u0010': '[', '\u0011': ']', '\u0012': '0', '\u0013': '1', '\u0014': '2', '\u0015': '3', '\u0016': '4', '\u0017': '5', '\u0018': '6', '\u0019': '7', '\u001A': '8', '\u001B': '9', '\u001c': '&#183;', '\u001D': '<', '\u001E': '-', '\u001F': '>',
            '\u007F': '<',
            '\u20ac': '<', '\u0081': '-', '\u201A': '>', '\u0192': '&#8364;', '\u201E': '0', '\u2026': '&#183;', '\u2021': '0', '\u02C6': '0', '\u2030': '0', '\u0160': ' ', '\u2039': '#', '\u0152': ' ', '\u008D': '&#187;', '\u017D': '&#183;', '\u008f': '&#183;',
            '\u0090': '[', '\u2018': ']', '\u2019': '0', '\u201C': '1', '\u201D': '2', '\u2022': '3', '\u2013': '4', '\u2014': '5', '\u02DC': '6', '\u2122': '7', '\u0161': '8', '\u203A': '9', '\u0153': '&#183;', '\u009D': '<', '\u017E': '-', '\u0178': '>',
            '\u00A0': ' ', '\u00A1': '!', '\u00A2': '"', '\u00A3': '#', '\u00A4': '$', '\u00A5': '%', '\u00A6': '&', '\u00A7': "'", '\u00A8': '(', '\u00A9': ')', '\u00AA': '*', '\u00AB': '+', '\u00AC': ',', '\u00AD': '-', '\u00AE': '.', '\u00AF': '/',
            '\u00B0': '0', '\u00B1': '1', '\u00B2': '2', '\u00B3': '3', '\u00B4': '4', '\u00B5': '5', '\u00B6': '6', '\u00B7': '7', '\u00B8': '8', '\u00B9': '9', '\u00BA': ':', '\u00BB': ';', '\u00BC': '<', '\u00BD': '=', '\u00BE': '>', '\u00BF': '?',
            '\u00C0': '@', '\u00C1': 'A', '\u00C2': 'B', '\u00C3': 'C', '\u00C4': 'D', '\u00C5': 'E', '\u00C6': 'F', '\u00C7': 'G', '\u00C8': 'H', '\u00C9': 'I', '\u00CA': 'J', '\u00CB': 'K', '\u00CC': 'L', '\u00CD': 'M', '\u00CE': 'N', '\u00CF': 'O',
            '\u00D0': 'P', '\u00D1': 'Q', '\u00D2': 'R', '\u00D3': 'S', '\u00D4': 'T', '\u00D5': 'U', '\u00D6': 'V', '\u00D7': 'W', '\u00D8': 'X', '\u00D9': 'Y', '\u00DA': 'Z', '\u00DB': '[', '\u00DC': '\\', '\u00DD': ']', '\u00DE': '^', '\u00DF': '_',
            '\u00E0': '`', '\u00E1': 'a', '\u00E2': 'b', '\u00E3': 'c', '\u00E4': 'd', '\u00E5': 'e', '\u00E6': 'f', '\u00E7': 'g', '\u00E8': 'h', '\u00E9': 'i', '\u00EA': 'j', '\u00EB': 'k', '\u00EC': 'l', '\u00ED': 'm', '\u00EE': 'n', '\u00EF': 'o',
            '\u00F0': 'p', '\u00F1': 'q', '\u00F2': 'r', '\u00F3': 's', '\u00F4': 't', '\u00F5': 'u', '\u00F6': 'v', '\u00F7': 'w', '\u00F8': 'x', '\u00F9': 'y', '\u00FA': 'z', '\u00FB': '{', '\u00FC': '|', '\u00FD': '}', '\u00FE': '~', '\u00FF': '<'
        }

        // get map descriptions
        function displayWorldspawnData(worldspawnData) {
            console.log("Display Worldspawn Data called with:", worldspawnData);

            if (!worldspawnData) {
                console.error('No worldspawn data to display');
                return;
            }

            // Find the div where the data should be displayed
            var previewDiv = document.getElementById('worldspawn-preview');
            if (!previewDiv) {
                console.error('Preview element not found');
                return;
            }

            // Start building the HTML content
            var contentHtml = '<h3>Worldspawn Data</h3>';
            console.log("Building HTML content for worldspawn data");

            // Add each key-value pair as a paragraph
            for (var key in worldspawnData) {
                console.log("Adding data:", key, worldspawnData[key]);
                contentHtml += `<p><strong>${key}:</strong> ${worldspawnData[key]}</p>`;
            }

            // Update the inner HTML of the preview div
            previewDiv.innerHTML = contentHtml;
            console.log("Updated HTML content in preview div");
        }

        // just show image, with less info than default QWT
        QuakeWebTools.ImageUtil.generateHTMLPreviewSimple = function (images, palette, element_id) {
            var IU = QuakeWebTools.ImageUtil;
            var fragment = new DocumentFragment();

            var image_datas = images.image_datas || null;
            var image_infos = images.image_infos || null;
            var arraybuffer = images.arraybuffer || null;
            var limit = (image_datas) ? image_datas.length : image_infos.length;

            for (var i = 0; i < limit; ++i) {
                if (image_datas) {
                    var image_data = image_datas[i];
                } else {
                    var image_info = image_infos[i];
                    var image_data = IU.getImageData(image_info.name, arraybuffer, image_info);
                }
                var img_info = " (" + image_data.width + "x"
                    + image_data.height + ")";
                var img = IU.expandImageData(image_data, palette);
                img.title = image_data.name + img_info;
                //img.download = name + ".png"; // seems to have no effect...


                // woods simple display
                var div = document.createElement("div");
                div.className = "item-box";
                div.appendChild(img);
                div.innerHTML += "";

                fragment.appendChild(div);
            }

            var element = document.getElementById(element_id);
            if (element) {
                element.appendChild(fragment);
            } else {
                document.body.appendChild(fragment);
        }
    }

        const MD3_TEXTURE_EXTENSIONS = ['.png', '.jpg', '.jpeg', '.tga'];
        const ACTIVE_RENDERERS = window.Q1ToolsMD3ActiveRenderers || [];
        window.Q1ToolsMD3ActiveRenderers = ACTIVE_RENDERERS;
        const MD3_RENDERER_BUDGET = Number.POSITIVE_INFINITY;
        const MD3_SAFE_RENDERER_LIMIT = window.Q1ToolsMD3SafeRendererLimit || 10;
        const TEXTURE_BUFFER_MAP = window.Q1ToolsMD3TextureBufferMap || new Map();
        window.Q1ToolsMD3TextureBufferMap = TEXTURE_BUFFER_MAP;
        const TEXTURE_WAITERS = window.Q1ToolsMD3TextureWaiters || new Map();
        window.Q1ToolsMD3TextureWaiters = TEXTURE_WAITERS;
        const TEXTURE_MIME_TYPES = {
            png: 'image/png',
            jpg: 'image/jpeg',
            jpeg: 'image/jpeg',
            tga: 'image/x-tga'
        };
        const MD3_PREVIEW_REGISTRY = window.Q1ToolsMD3PreviewRegistry || new WeakMap();
        window.Q1ToolsMD3PreviewRegistry = MD3_PREVIEW_REGISTRY;
        let md3ViewportObserver = window.Q1ToolsMD3ViewportObserver || null;

        function isElementInViewport(element, margin = 0) {
            if (!element || typeof element.getBoundingClientRect !== 'function') {
                return false;
            }
            const rect = element.getBoundingClientRect();
            const height = window.innerHeight || document.documentElement.clientHeight || 0;
            const width = window.innerWidth || document.documentElement.clientWidth || 0;
            return rect.bottom >= -margin &&
                rect.top <= height + margin &&
                rect.right >= -margin &&
                rect.left <= width + margin;
        }

        function ensureMd3ViewportObserver() {
            if (!('IntersectionObserver' in window)) {
                return null;
            }
            if (!md3ViewportObserver) {
                md3ViewportObserver = new IntersectionObserver(handleMd3PreviewVisibility, {
                    root: null,
                    rootMargin: '160px 0px',
                    threshold: 0.1
                });
                window.Q1ToolsMD3ViewportObserver = md3ViewportObserver;
            }
            return md3ViewportObserver;
        }

        function handleMd3PreviewVisibility(entries) {
            let releasedSomething = false;
            entries.forEach((entry) => {
                const previewCell = entry.target;
                const metadata = MD3_PREVIEW_REGISTRY.get(previewCell);
                if (!metadata) {
                    if (md3ViewportObserver) {
                        md3ViewportObserver.unobserve(previewCell);
                    }
                    return;
                }
                metadata.isInViewport = entry.isIntersecting;
                if (entry.isIntersecting) {
                    requestMd3RenderIfNeeded(previewCell);
                } else {
                    releasedSomething = true;
                }
            });
            if (releasedSomething) {
                maybeReduceMd3RendererPressure();
            }
        }

        function requestMd3RenderIfNeeded(previewCell) {
            const metadata = MD3_PREVIEW_REGISTRY.get(previewCell);
            if (!metadata || metadata.hasActiveRenderer || metadata.isRendering) {
                return;
            }
            metadata.isRendering = true;
            renderMD3Preview(metadata.arrayBuffer, previewCell, metadata.filename);
        }

        function registerMd3Preview(previewCell, filename, arrayBuffer) {
            if (!(arrayBuffer instanceof ArrayBuffer)) {
                previewCell.textContent = 'MD3 data unavailable.';
                return;
            }
            const metadata = {
                filename,
                arrayBuffer,
                hasActiveRenderer: false,
                isRendering: false,
                isInViewport: false
            };
            MD3_PREVIEW_REGISTRY.set(previewCell, metadata);

            if (!('IntersectionObserver' in window)) {
                metadata.isInViewport = true;
                metadata.isRendering = true;
                renderMD3Preview(arrayBuffer, previewCell, filename);
                return;
            }

            const observer = ensureMd3ViewportObserver();
            metadata.isInViewport = isElementInViewport(previewCell, 120);
            if (observer) {
                observer.observe(previewCell);
            }

            if (metadata.isInViewport) {
                requestMd3RenderIfNeeded(previewCell);
            } else {
                previewCell.textContent = 'Scroll to load MD3 preview.';
            }
        }

        function maybeReduceMd3RendererPressure(force = false) {
            if (Number.isFinite(MD3_RENDERER_BUDGET)) {
                return false;
            }
            const limit = Math.max(1, MD3_SAFE_RENDERER_LIMIT || 8);
            const needsRelease = force ? ACTIVE_RENDERERS.length >= limit : ACTIVE_RENDERERS.length > limit;
            if (!needsRelease) {
                return false;
            }

            const offscreen = [];
            const fallback = [];
            ACTIVE_RENDERERS.forEach((record) => {
                if (!record || record.released) {
                    return;
                }
                const metadata = record.previewCell ? MD3_PREVIEW_REGISTRY.get(record.previewCell) : null;
                if (metadata) {
                    if (metadata.isInViewport) {
                        fallback.push(record);
                    } else {
                        offscreen.push(record);
                    }
                } else {
                    fallback.push(record);
                }
            });

            const victims = (offscreen.length ? offscreen : fallback).slice();
            let released = false;
            const comparator = force
                ? () => ACTIVE_RENDERERS.length >= limit
                : () => ACTIVE_RENDERERS.length > limit;

            while (victims.length && comparator()) {
                const record = victims.shift();
                if (!record || record.released) {
                    continue;
                }
                const metadata = record.previewCell ? MD3_PREVIEW_REGISTRY.get(record.previewCell) : null;
                const silent = metadata ? !metadata.isInViewport : true;
                try {
                    record.release({ reason: 'budget', silent });
                    released = true;
                } catch (err) {
                    console.warn('Failed to release MD3 renderer for pressure relief', err);
                }
            }
            return released;
        }

        function normalizeTexturePath(path) {
            if (!path) return '';
            return path.split('\u0000')[0]
                .replace(/\\/g, '/')
                .replace(/^\/+/, '')
                .toLowerCase();
        }
        function registerMD3TextureBuffer(path, arrayBuffer) {
            if (!path || !(arrayBuffer instanceof ArrayBuffer)) {
                return;
            }
            const cleaned = normalizeTexturePath(path);
            if (!cleaned) {
                return;
            }
            if (!TEXTURE_BUFFER_MAP.has(cleaned)) {
                console.log('[MD3] Registered texture buffer', cleaned, 'size', arrayBuffer.byteLength);
            }
            TEXTURE_BUFFER_MAP.set(cleaned, { buffer: arrayBuffer, originalPath: path });

            const waiters = TEXTURE_WAITERS.get(cleaned);
            if (waiters && waiters.length) {
                TEXTURE_WAITERS.delete(cleaned);
                console.log('[MD3] Resolving texture waiters for', cleaned);
                const ext = cleaned.split('.').pop() || '';
                waiters.forEach((resolver) => {
                    // Handle TGA asynchronously by converting to PNG data URL
                    if (ext.toLowerCase() === 'tga') {
                        const tgaBlob = new Blob([arrayBuffer], { type: 'image/x-tga' });
                        convertTgaBlobToDataUrl(tgaBlob)
                            .then((dataUrl) => {
                                resolver({ url: dataUrl, cleanup: null });
                            })
                            .catch((error) => {
                                console.warn('TGA conversion failed during waiter resolution, falling back to object URL:', error);
                                const fallbackUrl = URL.createObjectURL(tgaBlob);
                                resolver({ url: fallbackUrl, cleanup: () => URL.revokeObjectURL(fallbackUrl) });
                            });
                        return;
                    }
                    const mime = TEXTURE_MIME_TYPES[ext] || 'application/octet-stream';
                    const blob = new Blob([arrayBuffer], { type: mime });
                    const objectUrl = URL.createObjectURL(blob);
                    resolver({
                        url: objectUrl,
                        cleanup: () => URL.revokeObjectURL(objectUrl)
                    });
                });
            }
        }

        function findBlobByPakPath(path, extension) {
            if (!path) return null;
            const target = normalizeTexturePath(path);
            for (let i = 0; i < viewFileBlobs.length; i++) {
                const entry = viewFileBlobs[i];
                if (!entry || !entry.filename) continue;
                const entryPath = normalizeTexturePath(entry.filename);
                if (entryPath === target) {
                    return entry;
                }
            }
            if (Array.isArray(fileBlobs)) {
                for (let i = 0; i < fileBlobs.length; i++) {
                    const entry = fileBlobs[i];
                    if (!entry || !entry.name || !entry.blob) continue;
                    const entryPath = normalizeTexturePath(entry.name);
                    if (entryPath === target) {
                        console.log('[MD3] Found texture in fileBlobs fallback', entry.name);
                        return { filename: entry.name, blob: entry.blob };
                    }
                }
            }
            const bufferEntry = TEXTURE_BUFFER_MAP.get(target);
            if (bufferEntry) {
                const mimeType = TEXTURE_MIME_TYPES[extension] || 'application/octet-stream';
                console.log('[MD3] Found texture buffer for', path);
                return {
                    filename: bufferEntry.originalPath,
                    blob: new Blob([bufferEntry.buffer], { type: mimeType })
                };
            }
            return null;
        }

        function buildMD3TextureCandidates(filename, shaderNames) {
            const candidates = [];
            const seen = new Set();
            const idx = filename.lastIndexOf('/');
            const directory = idx !== -1 ? filename.slice(0, idx + 1) : '';
            const basename = idx !== -1 ? filename.slice(idx + 1) : filename;
            const baseWithoutExt = basename.replace(/\.[^/.]+$/, '');

            if (Array.isArray(shaderNames) && shaderNames.length) {
                console.log('[MD3] Raw shader names for', filename, shaderNames);
            } else {
                console.log('[MD3] No shader names found for', filename);
            }

            const pushCandidate = (rawPath) => {
                if (!rawPath) return;
                const normalized = rawPath.replace(/\\/g, '/');
                let cleaned = normalized;
                if (typeof cleaned === 'string') {
                    cleaned = cleaned.replace(/^\.\//, '');
                    cleaned = cleaned.replace(/^\/+/, '');
                    // collapse occurrences of `/./`
                    cleaned = cleaned.replace(/\/\.\//g, '/');
                    // resolve `../` segments without allowing traversal above root
                    const segments = [];
                    cleaned.split('/').forEach((segment) => {
                        if (!segment || segment === '.') {
                            return;
                        }
                        if (segment === '..') {
                            if (segments.length) {
                                segments.pop();
                            }
                            return;
                        }
                        segments.push(segment);
                    });
                    cleaned = segments.join('/');
                    if (!cleaned) {
                        return;
                    }
                }
                const lower = cleaned.toLowerCase();
                if (seen.has(lower)) return;
                seen.add(lower);
                candidates.push(cleaned);
            };

            const pushWithExtensions = (rawPath) => {
                if (!rawPath) return;
                if (/\.[a-z0-9]+$/i.test(rawPath)) {
                    pushCandidate(rawPath);
                } else {
                    MD3_TEXTURE_EXTENSIONS.forEach(ext => pushCandidate(rawPath + ext));
                }
            };

            if (Array.isArray(shaderNames)) {
                shaderNames.forEach((name) => {
                    if (!name) return;
                    const trimmed = name.trim();
                    if (!trimmed) return;
                    pushWithExtensions(trimmed);
                    if (directory) {
                        pushWithExtensions(directory + trimmed);
                    }
                });
            }

            MD3_TEXTURE_EXTENSIONS.forEach(ext => pushCandidate(directory + baseWithoutExt + ext));

            return candidates;
        }

        function convertTgaBlobToDataUrl(blob) {
            if (typeof TgaLoader !== 'function') {
                return Promise.reject(new Error('TgaLoader unavailable'));
            }
            return blob.arrayBuffer().then((buffer) => {
                const loader = new TgaLoader();
                loader.load(new Uint8Array(buffer));
                const canvas = loader.getCanvas();
                if (!canvas) {
                    throw new Error('TGA conversion failed: no canvas generated');
                }
                return canvas.toDataURL('image/png');
            });
        }

        function resolveMD3TextureResource(filename, shaderNames) {
            const availablePaths = [];
            (viewFileBlobs || []).forEach((entry) => {
                if (!entry || !entry.filename) return;
                availablePaths.push(entry.filename.split('\u0000')[0].replace(/\\/g, '/'));
            });
            if (Array.isArray(fileBlobs)) {
                fileBlobs.forEach((entry) => {
                    if (!entry || !entry.name) return;
                    const cleaned = entry.name.split('\u0000')[0].replace(/\\/g, '/');
                    if (!availablePaths.includes(cleaned)) {
                        availablePaths.push(cleaned);
                    }
                });
            }
            const candidates = buildMD3TextureCandidates(filename, shaderNames);
            if (candidates.length) {
                console.log('[MD3] Texture candidates for', filename, candidates);
                console.log('[MD3] Available blob paths from viewFileBlobs', availablePaths);
                console.log('[MD3] Texture buffer keys', Array.from(TEXTURE_BUFFER_MAP.keys()));
            } else {
                console.log('[MD3] No texture candidates for', filename);
                console.log('[MD3] Available blob paths from viewFileBlobs', availablePaths);
                console.log('[MD3] Texture buffer keys', Array.from(TEXTURE_BUFFER_MAP.keys()));
            }
            if (!candidates.length) {
                return Promise.resolve(null);
            }

            const tryResolve = (index) => {
                if (index >= candidates.length) {
                    console.warn('[MD3] Exhausted texture candidates for', filename);
                    return Promise.resolve(null);
                }

                const candidatePath = candidates[index];
                const extensionMatch = /\.([a-z0-9]+)$/i.exec(candidatePath);
                const extension = extensionMatch ? extensionMatch[1].toLowerCase() : '';
                const blobEntry = findBlobByPakPath(candidatePath, extension);
                if (!blobEntry) {
                    console.warn('[MD3] Candidate not found in blob map', candidatePath);
                    return tryResolve(index + 1);
                }
                console.log('[MD3] Using texture candidate', candidatePath, 'for', filename);

                if (extension === 'tga') {
                    return convertTgaBlobToDataUrl(blobEntry.blob)
                        .then((dataUrl) => ({ url: dataUrl, cleanup: null }))
                        .catch((error) => {
                            console.warn(`Failed to convert TGA texture ${candidatePath}:`, error);
                            return tryResolve(index + 1);
                        });
                }

                const objectUrl = URL.createObjectURL(blobEntry.blob);
                return Promise.resolve({
                    url: objectUrl,
                    cleanup: () => URL.revokeObjectURL(objectUrl)
                });
            };

            return tryResolve(0).then((result) => {
                if (result) {
                    return result;
                }
                return waitForTexture(candidates, filename);
            });
        }

        function waitForTexture(candidates, filename) {
            const normalizedCandidates = candidates.map(normalizeTexturePath).filter(Boolean);
            if (!normalizedCandidates.length) {
                return Promise.resolve(null);
            }
            // Immediate check: a texture may have been registered before we started waiting
            for (let i = 0; i < normalizedCandidates.length; i++) {
                const key = normalizedCandidates[i];
                const bufferEntry = TEXTURE_BUFFER_MAP.get(key);
                if (bufferEntry) {
                    const ext = (key.split('.').pop() || '').toLowerCase();
                    if (ext === 'tga') {
                        const tgaBlob = new Blob([bufferEntry.buffer], { type: 'image/x-tga' });
                        return convertTgaBlobToDataUrl(tgaBlob)
                            .then((dataUrl) => ({ url: dataUrl, cleanup: null }))
                            .catch((error) => {
                                console.warn('TGA conversion failed during immediate waiter check, falling back to object URL:', error);
                                const fallbackUrl = URL.createObjectURL(tgaBlob);
                                return { url: fallbackUrl, cleanup: () => URL.revokeObjectURL(fallbackUrl) };
                            });
                    }
                    const mime = TEXTURE_MIME_TYPES[ext] || 'application/octet-stream';
                    const blob = new Blob([bufferEntry.buffer], { type: mime });
                    const objectUrl = URL.createObjectURL(blob);
                    return Promise.resolve({ url: objectUrl, cleanup: () => URL.revokeObjectURL(objectUrl) });
                }
            }
            console.log('[MD3] Waiting for texture registration for', filename, normalizedCandidates);
            return new Promise((resolve) => {
                let resolved = false;
                const handles = [];

                const cleanup = () => {
                    handles.forEach(({ key, resolver }) => {
                        const list = TEXTURE_WAITERS.get(key);
                        if (!list) return;
                        const index = list.indexOf(resolver);
                        if (index !== -1) {
                            list.splice(index, 1);
                        }
                        if (!list.length) {
                            TEXTURE_WAITERS.delete(key);
                        }
                    });
                };

                normalizedCandidates.forEach((key) => {
                    const resolver = (resource) => {
                        if (resolved) {
                            if (resource && resource.cleanup) {
                                resource.cleanup();
                            }
                            return;
                        }
                        resolved = true;
                        cleanup();
                        resolve(resource);
                    };
                    let list = TEXTURE_WAITERS.get(key);
                    if (!list) {
                        list = [];
                        TEXTURE_WAITERS.set(key, list);
                    }
                    list.push(resolver);
                    handles.push({ key, resolver });
                });

                setTimeout(() => {
                    if (resolved) return;
                    resolved = true;
                    cleanup();
                    console.warn('[MD3] Texture wait timed out for', filename);
                    resolve(null);
                }, 3000);
            });
        }

        function renderMD3Preview(arrayBuffer, previewCell, filename) {
            console.log('[MD3] Render preview requested for', filename);
            const metadata = MD3_PREVIEW_REGISTRY.get(previewCell);
            if (metadata && arrayBuffer instanceof ArrayBuffer) {
                metadata.arrayBuffer = arrayBuffer;
                metadata.lastRenderError = null;
            }
            if (!(arrayBuffer instanceof ArrayBuffer)) {
                previewCell.textContent = 'MD3 data unavailable.';
                if (metadata) {
                    metadata.isRendering = false;
                    metadata.hasActiveRenderer = false;
                }
                return;
            }
            if (metadata) {
                metadata.isRendering = true;
            }

            previewCell.textContent = 'Loading MD3 preview...';

            const hydrate = (support) => {
                if (!support) {
                    previewCell.textContent = 'MD3 preview unavailable.';
                    if (metadata) {
                        metadata.isRendering = false;
                        metadata.hasActiveRenderer = false;
                    }
                    return;
                }

                const { THREE, OrbitControls, MD3Loader } = support;
                console.log('[MD3] Hydrated support for', filename, '->', !!THREE, !!OrbitControls, !!MD3Loader);

                if (!THREE || !OrbitControls || !MD3Loader) {
                    previewCell.textContent = 'MD3 preview unavailable.';
                    if (metadata) {
                        metadata.isRendering = false;
                        metadata.hasActiveRenderer = false;
                    }
                    return;
                }

                try {
                    const loader = new MD3Loader();
                    loader.scale = 1 / 64;
                    const mesh = loader.parse(arrayBuffer);
                    console.log('[MD3] Parsed mesh for', filename, mesh ? 'success' : 'failure');

                    if (!mesh) {
                        previewCell.textContent = 'Unable to parse MD3 file.';
                        if (metadata) {
                            metadata.isRendering = false;
                            metadata.hasActiveRenderer = false;
                            metadata.lastRenderError = new Error('MD3 parse failure');
                        }
                        return;
                    }

                    if (typeof previewCell.__md3Release === 'function') {
                        try {
                            previewCell.__md3Release({ clearContainer: true });
                        } catch (releaseError) {
                            console.warn('Failed to release previous MD3 preview', releaseError);
                        }
                    }

                    if (mesh.material && typeof mesh.material.dispose === 'function') {
                        mesh.material.dispose();
                    }

                    mesh.material = new THREE.MeshStandardMaterial({
                        color: 0xdddddd,
                        metalness: 0.1,
                        roughness: 0.75
                    });

                    if (mesh.userData && Array.isArray(mesh.userData.shaderNames)) {
                        console.log('[MD3] Shader names for', filename, mesh.userData.shaderNames);
                    }

                    previewCell.innerHTML = '';
                    const container = document.createElement('div');
                    container.className = 'md3-preview-container';
                    previewCell.appendChild(container);

                    const width = container.clientWidth || 240;
                    const height = container.clientHeight || 240;

                    const scene = new THREE.Scene();
                    const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 2000);
                    if (!Number.isFinite(MD3_RENDERER_BUDGET)) {
                        maybeReduceMd3RendererPressure(true);
                    }
                    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                    renderer.setPixelRatio(window.devicePixelRatio || 1);
                    renderer.setSize(width, height, false);
                    container.appendChild(renderer.domElement);

                    mesh.geometry.computeBoundingSphere();
                    mesh.geometry.computeBoundingBox();

                    const pivot = new THREE.Group();
                    pivot.add(mesh);
                    scene.add(pivot);
                    const basePivotRotation = new THREE.Euler(Math.PI / 2, Math.PI, 0, 'XYZ');
                    const userPivotRotation = { x: 0, y: 0 };
                    const applyPivotRotation = () => {
                        pivot.rotation.set(
                            basePivotRotation.x + userPivotRotation.x,
                            basePivotRotation.y + userPivotRotation.y,
                            basePivotRotation.z
                        );
                    };

                    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                    scene.add(ambientLight);
                    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
                    directionalLight.position.set(6, 8, 10);
                    scene.add(directionalLight);

                    let radius = 1;
                    if (mesh.geometry.boundingSphere) {
                        const center = mesh.geometry.boundingSphere.center.clone();
                        radius = Math.max(mesh.geometry.boundingSphere.radius, 0.001);
                        mesh.position.sub(center);
                    }

                    applyPivotRotation();

                    const distance = Math.max(radius * 3.5, 2);
                    camera.position.set(distance, distance, distance);
                    camera.near = Math.max(distance / 100, 0.01);
                    camera.far = distance * 20;
                    camera.lookAt(new THREE.Vector3(0, 0, 0));
                    camera.updateProjectionMatrix();

                    let controls;
                    let releaseRenderer;
                    let rendererRecord;
                    let disposed = false;
                    const previousThree = window.THREE;
                    try {
                        window.THREE = THREE;
                        controls = new OrbitControls(camera, renderer.domElement);
                    } finally {
                        if (previousThree === undefined) {
                            delete window.THREE;
                        } else {
                            window.THREE = previousThree;
                        }
                    }
                    if (!controls) {
                        previewCell.textContent = 'MD3 preview unavailable.';
                        return;
                    }

                    controls.enablePan = false;
                    controls.enableDamping = true;
                    controls.dampingFactor = 0.08;
                    controls.enableZoom = true;
                    if (typeof controls.enableRotate !== 'undefined') {
                        controls.enableRotate = false;
                    }
                    if ('noPan' in controls) {
                        controls.noPan = true;
                    }
                    if ('noZoom' in controls) {
                        controls.noZoom = false;
                    }
                    if ('noRotate' in controls) {
                        controls.noRotate = true;
                    }
                    controls.autoRotate = false;
                    controls.zoomSpeed = 1.0;
                    controls.rotateSpeed = 0.9;
                    if (controls.mouseButtons) {
                        const mouse = THREE.MOUSE || { ROTATE: 0, DOLLY: 1, PAN: 2 };
                        controls.mouseButtons.LEFT = mouse.PAN !== undefined ? mouse.PAN : 2;
                        controls.mouseButtons.MIDDLE = mouse.DOLLY !== undefined ? mouse.DOLLY : 1;
                        controls.mouseButtons.RIGHT = mouse.PAN !== undefined ? mouse.PAN : 2;
                    }
                    if (controls.touches) {
                        const touch = THREE.TOUCH || { ROTATE: 0, DOLLY_PAN: 1 };
                        controls.touches.ONE = touch.DOLLY_PAN !== undefined ? touch.DOLLY_PAN : 1;
                        controls.touches.TWO = touch.DOLLY_PAN !== undefined ? touch.DOLLY_PAN : 1;
                    }
                    controls.target.set(0, 0, 0);
                    controls.update();

                    const canvasEl = renderer.domElement;
                    canvasEl.style.cursor = 'grab';
                    canvasEl.style.touchAction = 'none';
                    const rotationClamp = (value, min, max) => {
                        if (THREE.MathUtils && typeof THREE.MathUtils.clamp === 'function') {
                            return THREE.MathUtils.clamp(value, min, max);
                        }
                        return Math.min(Math.max(value, min), max);
                    };
                    let isDragging = false;
                    let activePointerId = null;
                    let lastPointerX = 0;
                    let lastPointerY = 0;

                    const handlePointerDown = (event) => {
                        if (typeof event.button === 'number' && event.button !== 0) {
                            return;
                        }
                        isDragging = true;
                        lastPointerX = event.clientX;
                        lastPointerY = event.clientY;
                        canvasEl.style.cursor = 'grabbing';
                        if (canvasEl.setPointerCapture && event.pointerId !== undefined) {
                            try {
                                canvasEl.setPointerCapture(event.pointerId);
                            } catch (captureError) {
                                console.warn('Pointer capture failed:', captureError);
                            }
                        }
                        if (event.pointerId !== undefined) {
                            activePointerId = event.pointerId;
                        }
                    };

                    const handlePointerMove = (event) => {
                        if (!isDragging) {
                            return;
                        }
                        event.preventDefault();
                        const deltaX = event.clientX - lastPointerX;
                        const deltaY = event.clientY - lastPointerY;
                        const rotationSpeed = 0.01;
                        userPivotRotation.y -= deltaX * rotationSpeed;
                        userPivotRotation.x -= deltaY * rotationSpeed;
                        const maxPitch = Math.PI / 2.2;
                        userPivotRotation.x = rotationClamp(userPivotRotation.x, -maxPitch, maxPitch);
                        applyPivotRotation();
                        lastPointerX = event.clientX;
                        lastPointerY = event.clientY;
                    };

                    const endPointerDrag = (event) => {
                        if (!isDragging) {
                            return;
                        }
                        if (canvasEl.releasePointerCapture && activePointerId !== null) {
                            try {
                                canvasEl.releasePointerCapture(activePointerId);
                            } catch (releaseError) {
                                // ignore
                            }
                        }
                        activePointerId = null;
                        isDragging = false;
                        canvasEl.style.cursor = 'grab';
                    };

                    rendererRecord = { renderer, container, released: false, previewCell, filename };
                    releaseRenderer = (options = {}) => {
                        if (rendererRecord.released) {
                            return;
                        }
                        rendererRecord.released = true;
                        disposed = true;
                        const metadataForCell = MD3_PREVIEW_REGISTRY.get(previewCell);
                        if (metadataForCell) {
                            metadataForCell.hasActiveRenderer = false;
                            metadataForCell.isRendering = false;
                        }
                        if (container && container.__md3AnimationId) {
                            cancelAnimationFrame(container.__md3AnimationId);
                            container.__md3AnimationId = null;
                        }
                        const recordIndex = ACTIVE_RENDERERS.indexOf(rendererRecord);
                        if (recordIndex !== -1) {
                            ACTIVE_RENDERERS.splice(recordIndex, 1);
                        }
                        if (previewCell.__md3Release === releaseRenderer) {
                            delete previewCell.__md3Release;
                        }
                        isDragging = false;
                        canvasEl.removeEventListener('pointerdown', handlePointerDown);
                        canvasEl.removeEventListener('pointermove', handlePointerMove);
                        canvasEl.removeEventListener('pointerup', endPointerDrag);
                        canvasEl.removeEventListener('pointerleave', endPointerDrag);
                        canvasEl.removeEventListener('lostpointercapture', endPointerDrag);
                        if (controls && typeof controls.dispose === 'function') {
                            try {
                                controls.dispose();
                            } catch (controlsError) {
                                console.warn('Failed to dispose MD3 controls', controlsError);
                            }
                        }
                        if (renderer) {
                            try {
                                renderer.dispose();
                            } catch (disposeError) {
                                console.warn('Failed to dispose MD3 renderer', disposeError);
                            }
                            if (typeof renderer.forceContextLoss === 'function') {
                                try {
                                    renderer.forceContextLoss();
                                } catch (contextError) {
                                    console.warn('Failed to force context loss', contextError);
                                }
                            }
                        }
                        if (options.reason === 'budget' && container) {
                            container.innerHTML = '';
                            if (!options.silent) {
                                const msg = document.createElement('div');
                                msg.className = 'md3-preview-unloaded';
                                msg.textContent = 'Preview unloaded to free GPU resources.';
                                const reloadBtn = document.createElement('button');
                                reloadBtn.className = 'md3-preview-reload-btn';
                                reloadBtn.textContent = 'Reload Preview';
                                reloadBtn.addEventListener('click', () => {
                                    let freed = false;
                                    if (Number.isFinite(MD3_RENDERER_BUDGET)) {
                                        while (ACTIVE_RENDERERS.length >= MD3_RENDERER_BUDGET && ACTIVE_RENDERERS.length) {
                                            const oldest = ACTIVE_RENDERERS[0];
                                            if (oldest && typeof oldest.release === 'function') {
                                                try {
                                                    oldest.release({ reason: 'budget', silent: true });
                                                    freed = true;
                                                } catch (innerReleaseError) {
                                                    console.warn('Failed to release MD3 preview for reload', innerReleaseError);
                                                    break;
                                                }
                                            } else {
                                                break;
                                            }
                                        }
                                    } else {
                                        freed = maybeReduceMd3RendererPressure(true);
                                        if (!freed && ACTIVE_RENDERERS.length) {
                                            const oldest = ACTIVE_RENDERERS[0];
                                            if (oldest && typeof oldest.release === 'function') {
                                                try {
                                                    oldest.release({ reason: 'budget', silent: true });
                                                    freed = true;
                                                } catch (innerReleaseError) {
                                                    console.warn('Failed to release MD3 preview for reload', innerReleaseError);
                                                }
                                            }
                                        }
                                    }
                                    const reloadMetadata = MD3_PREVIEW_REGISTRY.get(previewCell);
                                    const bufferSource = reloadMetadata && reloadMetadata.arrayBuffer ? reloadMetadata.arrayBuffer : arrayBuffer;
                                    renderMD3Preview(bufferSource, previewCell, filename);
                                });
                                container.appendChild(msg);
                                container.appendChild(reloadBtn);
                            } else {
                                const metadataForCellAgain = MD3_PREVIEW_REGISTRY.get(previewCell);
                                if (metadataForCellAgain && metadataForCellAgain.isInViewport) {
                                    const pausedMsg = document.createElement('div');
                                    pausedMsg.className = 'md3-preview-paused';
                                    pausedMsg.textContent = 'Preview will resume when resources free up.';
                                    container.appendChild(pausedMsg);
                                }
                            }
                        } else if (options.clearContainer && container) {
                            container.innerHTML = '';
                        }
                        if (!document.body.contains(previewCell) && md3ViewportObserver) {
                            md3ViewportObserver.unobserve(previewCell);
                            MD3_PREVIEW_REGISTRY.delete(previewCell);
                        }
                    };
                    rendererRecord.release = releaseRenderer;
                    ACTIVE_RENDERERS.push(rendererRecord);
                    if (metadata) {
                        metadata.hasActiveRenderer = true;
                        metadata.isRendering = false;
                    }
                    if (Number.isFinite(MD3_RENDERER_BUDGET)) {
                        while (ACTIVE_RENDERERS.length > MD3_RENDERER_BUDGET) {
                            const oldest = ACTIVE_RENDERERS.shift();
                            if (oldest && typeof oldest.release === 'function') {
                                try {
                                    oldest.release({ reason: 'budget' });
                                } catch (budgetError) {
                                    console.warn('Failed to release MD3 renderer for budget', budgetError);
                                }
                            }
                        }
                    } else {
                        maybeReduceMd3RendererPressure();
                    }
                    previewCell.__md3Release = releaseRenderer;

                    canvasEl.addEventListener('pointerdown', handlePointerDown);
                    canvasEl.addEventListener('pointermove', handlePointerMove);
                    canvasEl.addEventListener('pointerup', endPointerDrag);
                    canvasEl.addEventListener('pointerleave', endPointerDrag);
                    canvasEl.addEventListener('lostpointercapture', endPointerDrag);
                    resolveMD3TextureResource(filename, mesh.userData && mesh.userData.shaderNames)
                        .then((resource) => {
                            if (!resource || !resource.url) {
                                console.debug('[MD3] No texture resource resolved for', filename);
                                return;
                            }
                            const textureLoader = new THREE.TextureLoader();
                            textureLoader.load(resource.url, (texture) => {
                                texture.flipY = false;
                                mesh.traverse((child) => {
                                    if (child.isMesh) {
                                        if (Array.isArray(child.material)) {
                                            child.material.forEach((mat) => {
                                                mat.map = texture;
                                                mat.needsUpdate = true;
                                            });
                                        } else if (child.material) {
                                            child.material.map = texture;
                                            child.material.needsUpdate = true;
                                        }
                                    }
                                });
                                if (resource.cleanup) {
                                    resource.cleanup();
                                }
                            }, undefined, (error) => {
                                console.warn(`Failed to load MD3 texture for ${filename}:`, error);
                                if (resource.cleanup) {
                                    resource.cleanup();
                                }
                            });
                        })
                        .catch((error) => {
                            console.warn(`Texture resolution error for ${filename}:`, error);
                        });

                    const animate = () => {
                        if (disposed) {
                            return;
                        }
                        if (!document.body.contains(container)) {
                            if (container.__md3AnimationId) {
                                cancelAnimationFrame(container.__md3AnimationId);
                            }
                            releaseRenderer({ clearContainer: true });
                            return;
                        }
                        controls.update();
                        renderer.render(scene, camera);
                        container.__md3AnimationId = requestAnimationFrame(animate);
                    };
                    animate();
                } catch (err) {
                    console.error(`Error rendering MD3 preview for ${filename}:`, err);
                    previewCell.textContent = 'Unable to render MD3 preview.';
                    if (metadata) {
                        metadata.isRendering = false;
                        metadata.hasActiveRenderer = false;
                        metadata.lastRenderError = err;
                    }
                    if (typeof releaseRenderer === 'function') {
                        releaseRenderer({ clearContainer: true });
                    }
                }
            };

            if (window.Q1ToolsMD3Support) {
                hydrate(window.Q1ToolsMD3Support);
                return;
            }

            if (window.Q1ToolsMD3SupportReady) {
                window.Q1ToolsMD3SupportReady.then(hydrate).catch(() => {
                    previewCell.textContent = 'MD3 preview unavailable.';
                });
                return;
            }

            const onReady = (event) => {
                hydrate(event.detail);
            };
            window.addEventListener('md3previewready', onReady, { once: true });

            setTimeout(() => {
                window.removeEventListener('md3previewready', onReady);
                if (!previewCell.querySelector('.md3-preview-container')) {
                    previewCell.textContent = 'MD3 preview unavailable.';
                }
            }, 5000);
        }

        function createMiniAudioPlayer(filename, fileArrayBuffer) {
            const audioBlob = new Blob([fileArrayBuffer], { type: 'audio/*' });
            const audioUrl = URL.createObjectURL(audioBlob);

            // Mini player container
            const playerContainer = document.createElement('div');
            playerContainer.className = 'mini-player';

            // Play/Pause button with Font Awesome icon
            const playPauseButton = document.createElement('button');
            playPauseButton.className = 'play-pause-btn';
            const playPauseIcon = document.createElement('i');
            playPauseIcon.className = 'fas fa-play'; // Initial icon as play
            playPauseButton.appendChild(playPauseIcon);

            // Progress bar
            const progressBar = document.createElement('div');
            progressBar.className = 'progress-bar';
            const progressIndicator = document.createElement('div');
            progressIndicator.className = 'progress-indicator';
            progressBar.appendChild(progressIndicator);

            // Create Howl instance
            var sound = new Howl({
                src: [audioUrl],
                format: ['mp3', 'ogg', 'wav'],
                onplay: () => {
                    playPauseIcon.className = 'fas fa-pause';
                    requestAnimationFrame(updateProgress); // Ensure progress bar updates
                },
                onpause: () => playPauseIcon.className = 'fas fa-play',
                onend: () => {
                    playPauseIcon.className = 'fas fa-play';
                    progressIndicator.style.width = '0%';
                }
            });

            // Play/Pause toggle
            playPauseButton.addEventListener('click', () => {
                if (sound.playing()) {
                    sound.pause();
                } else {
                    sound.play();
                }
            });

            // Update progress bar
            function updateProgress() {
                const seek = sound.seek() || 0;
                progressIndicator.style.width = `${(seek / sound.duration()) * 100}%`;
                if (sound.playing()) requestAnimationFrame(updateProgress);
            }

            // Scrubbing functionality
            progressBar.addEventListener('click', (event) => {
                const x = event.offsetX;
                const totalWidth = progressBar.offsetWidth;
                const percentage = x / totalWidth;
                const newTime = sound.duration() * percentage;
                sound.seek(newTime);
                if (!sound.playing()) {
                    updateProgress(); // Update the progress bar immediately
                }
            });

            // Append controls to the container
            playerContainer.appendChild(playPauseButton);
            playerContainer.appendChild(progressBar);

            return playerContainer;
        }

        function crc16ccitt(data) {
            let crc = 0xFFFF;
            for (let i = 0; i < data.length; i++) {
                crc ^= data[i] << 8;
                for (let j = 0; j < 8; j++) {
                    if (crc & 0x8000) {
                        crc = (crc << 1) ^ 0x1021;
                    } else {
                        crc = crc << 1;
                    }
                }
            }
            return crc & 0xFFFF;
        }

        function checkPopLmp(dataView, diroffset, dirlen) {
            let hasPop = false;
            let isPopCorrect = false;

            const numFiles = dirlen / 64;
            for (let i = 0; i < numFiles; i++) {
                const entryOffset = diroffset + i * 64;
                const fileName = getStringFromDataView(dataView, entryOffset, 56);

                if (fileName === "gfx/pop.lmp") {
                    hasPop = true;
                    const fileOffset = dataView.getUint32(entryOffset + 56, true);
                    const fileSize = dataView.getUint32(entryOffset + 60, true);

                    const popContent = new Uint16Array(dataView.buffer, fileOffset, fileSize / 2);
                    isPopCorrect = comparePopContent(popContent, expectedPop);
                    break;
                }
            }

            return { hasPop, isPopCorrect };
        }

        function getStringFromDataView(dataView, offset, length) {
            let str = "";
            for (let i = offset; i < offset + length; i++) {
                const charCode = dataView.getUint8(i);
                if (charCode === 0) break;
                str += String.fromCharCode(charCode);
            }
            return str;
        }

        function comparePopContent(popContent, expectedPop) {
            if (popContent.length !== expectedPop.length) return false;

            for (let i = 0; i < popContent.length; i++) {
                // Adjusting for potential endianness mismatch
                const popValue = adjustEndian(popContent[i]);
                if (popValue !== expectedPop[i]) return false;
            }
            return true;
        }

        function adjustEndian(value) {
            // Adjusts endianness of a 16-bit value
            return ((value & 0xFF) << 8) | ((value >> 8) & 0xFF);
        }

        const expectedPop = new Uint16Array([
            0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
            0x0000, 0x0000, 0x6600, 0x0000, 0x0000, 0x0000, 0x6600, 0x0000,
            0x0000, 0x0066, 0x0000, 0x0000, 0x0000, 0x0000, 0x0067, 0x0000,
            0x0000, 0x6665, 0x0000, 0x0000, 0x0000, 0x0000, 0x0065, 0x6600,
            0x0063, 0x6561, 0x0000, 0x0000, 0x0000, 0x0000, 0x0061, 0x6563,
            0x0064, 0x6561, 0x0000, 0x0000, 0x0000, 0x0000, 0x0061, 0x6564,
            0x0064, 0x6564, 0x0000, 0x6469, 0x6969, 0x6400, 0x0064, 0x6564,
            0x0063, 0x6568, 0x6200, 0x0064, 0x6864, 0x0000, 0x6268, 0x6563,
            0x0000, 0x6567, 0x6963, 0x0064, 0x6764, 0x0063, 0x6967, 0x6500,
            0x0000, 0x6266, 0x6769, 0x6a68, 0x6768, 0x6a69, 0x6766, 0x6200,
            0x0000, 0x0062, 0x6566, 0x6666, 0x6666, 0x6666, 0x6562, 0x0000,
            0x0000, 0x0000, 0x0062, 0x6364, 0x6664, 0x6362, 0x0000, 0x0000,
            0x0000, 0x0000, 0x0000, 0x0062, 0x6662, 0x0000, 0x0000, 0x0000,
            0x0000, 0x0000, 0x0000, 0x0061, 0x6661, 0x0000, 0x0000, 0x0000,
            0x0000, 0x0000, 0x0000, 0x0000, 0x6500, 0x0000, 0x0000, 0x0000,
            0x0000, 0x0000, 0x0000, 0x0000, 0x6400, 0x0000, 0x0000, 0x0000
        ]);

        // custom mdl viewer diff than QWT
        function viewMDL2(mdl, containerId, skinId) {
            var scene, camera, renderer;
            var mesh, controls;
            var animate_id = 0;
            var frame_id = 0;
            var model;

            function init() {
                var container = document.getElementById(containerId);
                if (!container) {
                    console.error('Container not found:', containerId);
                    return;
                }

                var width = container.offsetWidth - 200;
                var height = 200; // Set the desired height

                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(75, width / height, 1, 10000);

                scene.rotation.y = -Math.PI / 2;

                model = mdl.toThreeBufferGeometry(0); // Create model geometry
                var material = mdl.toThreeMaterial(skinId); // Create material
                mesh = new THREE.Mesh(model, material); // Create mesh

                scene.add(mesh);

                var radius = model.boundingSphere.radius;
                // Position the camera for a side view along the Y-axis
                camera.position.x = radius * 1.6;
                camera.position.y = 0;
                camera.position.z = 0; // Move camera along Z-axis to look from the side

                // Point the camera towards the center of the model
                camera.lookAt(new THREE.Vector3(0, 0, 0))


                // Update the mesh position if necessary
                mesh.position.x = -model.boundingSphere.center.x;
                mesh.position.y = -model.boundingSphere.center.y;
                mesh.position.z = -model.boundingSphere.center.z;




                renderer = new THREE.WebGLRenderer();
                renderer.setSize(width, height);
                renderer.setClearColor(0x2e2d2d); // Set background color
                container.appendChild(renderer.domElement);

                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.addEventListener('change', render);

                animate(model); // Start the animation
            }

            var lastFrameTime = 0;
            var frameDuration = 30; // Time in milliseconds for each frame

            function animate(timestamp) {
                animate_id = requestAnimationFrame(animate);

                if (timestamp - lastFrameTime > frameDuration) {
                    mdl.blendBufferGeometryFrame(model, frame_id);
                    frame_id = (frame_id + 1 / 6) % mdl.geometry.frames.length;
                    lastFrameTime = timestamp;
                }

                render();
            }

            function render() {
                renderer.render(scene, camera);
            }

            function loadModel() {
                init();
            }

            var container = document.getElementById(containerId);
            if (container) {
                if (!container.querySelector('.load-model-btn')) {
                    var loadModelButton = document.createElement('button');
                    loadModelButton.textContent = 'Load Model';
                    loadModelButton.className = 'load-model-btn';

                    loadModelButton.addEventListener('click', function () {
                        container.removeChild(loadModelButton);
                        loadModel();
                    });

                    container.appendChild(loadModelButton);
                }
            } else {
                console.error('Container not found:', containerId);
            }
        }

        // main function to handle all the file types for viewing
        function processFileEntries(entries, table) {
            if (Array.isArray(entries)) {
                entries.forEach((entry) => {
                    if (!entry || !entry.filename || !(entry.arrayBuffer instanceof ArrayBuffer)) {
                        return;
                    }
                    if (/\.(jpe?g|png|tga)$/i.test(entry.filename)) {
                        registerMD3TextureBuffer(entry.filename, entry.arrayBuffer);
                    }
                });
            }

            for (let i = 0; i < entries.length; i++) {
                const entry = entries[i];
                const filename = entry.filename;
                const arrayBuffer = entry.arrayBuffer;
                const fileBlob = entry.blob;
                const fileSize = entry.size;
                const formattedSize = formatFileSize(fileSize);

                viewFileBlobs.push({ filename, blob: fileBlob });

                const link = document.createElement('a');
                link.className = 'file-item';
                link.href = URL.createObjectURL(fileBlob);
                // Extract only the file name, not the full path
                const filenameOnly = filename.split('/').pop();
                link.download = filenameOnly;

                // Append the filename and file size to the link
                const filenameText = document.createTextNode(filename);
                const separatorSpan = document.createElement('span');
                separatorSpan.className = 'separator-style';
                separatorSpan.textContent = ' - ';
                const fileSizeSpan = document.createElement('span');
                fileSizeSpan.className = 'file-size';
                fileSizeSpan.textContent = formattedSize;
                link.appendChild(filenameText);
                link.appendChild(separatorSpan);
                link.appendChild(fileSizeSpan);

                // Create a table row for each file with name and preview
                const row = table.insertRow();
                const nameCell = row.insertCell();
                nameCell.appendChild(link);
                const previewCell = row.insertCell();
                previewCell.classList.add('preview-cell-style'); // Apply the style class


                // begin all the cases for diff file types (png, jpg, tga, bsp bmodels, bsp map descriptions, wav, mp3, ogg, spr, lmp, mdl)

                // png, jpg
                if (/\.(jpe?g|png)$/i.test(filename)) {
                    registerMD3TextureBuffer(filename, arrayBuffer);
                    const image = new Image();
                    image.src = link.href;
                    image.className = 'preview';
                    image.alt = 'Preview of ' + filename;
                    previewCell.appendChild(image);
                }

                // tga
                else if (/\.(tga)$/i.test(filename)) {
                    registerMD3TextureBuffer(filename, arrayBuffer);
                    const tga = new TgaLoader();
                    const fileBuffer = new Uint8Array(arrayBuffer);
                    tga.load(fileBuffer);
                    const imageCanvas = tga.getCanvas();
                    const scale = 256 / imageCanvas.width;
                    const scaledHeight = imageCanvas.height * scale;
                    imageCanvas.width = 256;
                    imageCanvas.height = scaledHeight;
                    const ctx = imageCanvas.getContext('2d');
                    ctx.drawImage(tga.getCanvas(), 0, 0, imageCanvas.width, imageCanvas.height);
                    imageCanvas.className = 'preview';
                    previewCell.appendChild(imageCanvas);
                }

                //bmodels
                else if (/\/b_(shell[01]|nail[01]|rock[01]|batt[01]|bh10|bh100|bh25)\.bsp$/i.test(filename)) {
                    console.log(`Debug: Processing BSP Filename = ${filename}`);

                    const fileArrayBuffer = arrayBuffer;

                    if (fileArrayBuffer.byteLength !== fileSize) {
                        console.error(`File size mismatch for ${filename}: Expected ${fileSize}, but got ${fileArrayBuffer.byteLength}`);
                        continue;
                    }

                    if (fileArrayBuffer instanceof ArrayBuffer) {
                        var bsp = new QuakeWebTools.BSP(filename, fileArrayBuffer);
                        console.log(`Debug: Created BSP object for ${filename}`);

                        // Dynamically create a container for the BSP preview
                        var previewContainer = document.createElement('div');
                        previewContainer.id = 'preview-container-' + i;
                        previewCell.appendChild(previewContainer);

                        // Define the array of filenames that should be displayed as 3D models
                        const gltfModels = ['b_batt0.gltf', 'b_batt1.gltf', 'b_bh10.gltf', 'b_bh100.gltf', 'b_bh25.gltf', 'b_nail0.gltf', 'b_nail1.gltf', 'b_rock0.gltf', 'b_rock1.gltf', 'b_shell0.gltf', 'b_shell1.gltf'];

                        // Extract the basename of the filename and replace .bsp with .gltf
                        const basename = filename.split('/').pop().replace('.bsp', '.gltf');

                        if (gltfModels.includes(basename)) {
                            console.log(`Debug: Creating Load Model button for ${basename}`);

                            // Create a button for lazy loading the model viewer
                            const loadModelButton = document.createElement('button');
                            loadModelButton.textContent = 'Load Model';
                            loadModelButton.className = 'load-model-btn';

                            // Event listener for button click
                            loadModelButton.addEventListener('click', function () {
                                // Create and configure the model-viewer element
                                const modelViewer = document.createElement('model-viewer');
                                modelViewer.setAttribute('alt', '');
                                modelViewer.setAttribute('src', 'bmodels/' + basename);
                                modelViewer.setAttribute('ar', '');
                                modelViewer.setAttribute('environment-image', '');
                                modelViewer.setAttribute('shadow-intensity', '1');
                                modelViewer.setAttribute('camera-controls', '');
                                modelViewer.setAttribute('touch-action', 'pan-y');

                                // Replace the button with the model viewer in the preview cell
                                previewCell.innerHTML = '';
                                previewCell.appendChild(modelViewer);

                                console.log(`Debug: Loaded model-viewer for ${basename}`);
                            });

                            // Append the Load Model button to the preview cell
                            previewCell.appendChild(loadModelButton);
                        } else {
                            console.log(`Debug: Generating HTML preview for ${filename}`);
                        }


                        // Use QWT.ImageUtil.generateHTMLPreview to generate preview in the 'file-content' element
                        QWT.ImageUtil.generateHTMLPreviewSimple({ image_infos: bsp.miptex_directory, arraybuffer: bsp.ab },
                            QWT.DEFAULT_PALETTE, previewContainer.id);

                    } else {
                        console.error(`Failed to create ArrayBuffer for ${filename}`);
                    }
                }






                // bsp -- show worldspawn map descriptions and dequake them
                else if (/\.bsp$/i.test(filename)) {
                    const bspPreview = document.createElement('div');
                    bspPreview.className = 'bsp-preview';
                    bspPreview.textContent = 'Loading BSP data...';

                    // Function to handle BSP file reading and displaying worldspawn data
                    const handleBspFile = (fileBlob) => {
                        const reader = new FileReader();
                        reader.onload = function (e) {
                            const buffer = e.target.result;
                            const entitiesData = extractEntitiesData(buffer);
                            const worldspawnData = parseWorldspawn(entitiesData);
                            if (worldspawnData && worldspawnData.message) {
                                bspPreview.textContent = worldspawnData.message;
                            } else {
                                bspPreview.textContent = '';
                            }
                        };
                        reader.readAsArrayBuffer(fileBlob);
                    };

                    // Call the function with the fileBlob
                    handleBspFile(fileBlob);
                    previewCell.appendChild(bspPreview);
                }

                // .map
                else if (/\.map$/i.test(filename)) {
                    const fileArrayBuffer = arrayBuffer;

                    // Convert the ArrayBuffer to a Uint8Array
                    const uint8Array = new Uint8Array(fileArrayBuffer);

                    // Convert the Uint8Array to a string (considering only the first part of the file for efficiency)
                    const chunkSize = 1024; // Adjust based on how deep you expect "message" to be
                    let fileText = '';
                    for (let i = 0; i < Math.min(uint8Array.length, chunkSize); i++) {
                        fileText += String.fromCharCode(uint8Array[i]);
                    }

                    // Regular expression to find the first occurrence of "message"
                    const messagePattern = /"message"\s+"([^"]+)"/;
                    const messageMatch = messagePattern.exec(fileText);

                    if (messageMatch) {
                        let messageText = messageMatch[1];
                        // dequake just in case
                        messageText = translateName(messageText);
                        previewCell.textContent = `${messageText}`;
                    } else {
                        previewCell.textContent = '';
                    }
                }

                // wad
                else if (/\.wad$/i.test(filename)) {
                    const fileArrayBuffer = arrayBuffer;

                    if (!(fileArrayBuffer instanceof ArrayBuffer)) {
                        console.error(`Invalid ArrayBuffer for ${filename}`);
                        previewCell.textContent = 'Error processing WAD file.';
                        continue;
                    }

                    try {
                        const fileEntry = G.FILEMANAGER.addFile(filename, fileArrayBuffer);
                        const wad = (fileEntry && fileEntry.obj instanceof QuakeWebTools.WAD)
                            ? fileEntry.obj
                            : new QuakeWebTools.WAD(filename, fileArrayBuffer);

                        const palette = QWT.DEFAULT_PALETTE;
                        if (!palette) {
                            console.warn('Palette not loaded; cannot render WAD textures.');
                            previewCell.textContent = 'Palette unavailable for preview.';
                            continue;
                        }

                        const wadBuffer = wad.ab || fileArrayBuffer;
                        const textureEntries = wad.directory.filter((entry) => entry && entry.size > 0 && entry.type !== QuakeWebTools.WAD.TYPE_PALETTE);

                        if (!textureEntries.length) {
                            previewCell.textContent = 'No textures found in WAD.';
                            continue;
                        }

                        const wadContainer = document.createElement('div');
                        wadContainer.className = 'wad-preview-grid';
                        previewCell.appendChild(wadContainer);

                        const fragment = document.createDocumentFragment();

                        textureEntries.forEach((entry) => {
                            try {
                                const imageData = QWT.ImageUtil.getImageData(entry.name, wadBuffer, entry);
                                if (!imageData || !imageData.width || !imageData.height) {
                                    return;
                                }
                                const needsMip = entry.type === QuakeWebTools.WAD.TYPE_MIPTEX && (imageData.width > 128 || imageData.height > 128);
                                const mipLevel = needsMip ? 2 : undefined;
                                const canvas = QWT.ImageUtil.expandImageData(imageData, palette, mipLevel);
                                if (!canvas) {
                                    return;
                                }

                                const maxDisplaySize = 112;
                                const largestDimension = Math.max(imageData.width, imageData.height);
                                const scale = largestDimension > maxDisplaySize ? maxDisplaySize / largestDimension : 1;
                                canvas.style.width = Math.max(1, Math.round(imageData.width * scale)) + 'px';
                                canvas.style.height = Math.max(1, Math.round(imageData.height * scale)) + 'px';
                                canvas.classList.add('wad-texture');
                                canvas.title = `${entry.name} (${imageData.width}x${imageData.height})`;

                                const textureWrapper = document.createElement('div');
                                textureWrapper.className = 'wad-texture-wrapper';
                                textureWrapper.appendChild(canvas);

                                const label = document.createElement('div');
                                label.className = 'wad-texture-label';
                                label.textContent = entry.name;
                                textureWrapper.appendChild(label);

                                fragment.appendChild(textureWrapper);
                            } catch (renderError) {
                                console.error(`Failed to render texture ${entry.name} from ${filename}`, renderError);
                            }
                        });
                        wadContainer.appendChild(fragment);
                    } catch (error) {
                        console.error(`Error processing WAD file ${filename}`, error);
                        previewCell.textContent = 'Error processing WAD file.';
                    }
                }

                else if (/\.ion$/i.test(filename)) {
                    const fileArrayBuffer = arrayBuffer;

                    let reader = new FileReader();
                    reader.onload = function (e) {
                        const fileText = e.target.result;
                        previewCell.textContent = fileText;  // Display the contents of the .ion file
                    };

                    reader.readAsText(new Blob([new Uint8Array(fileArrayBuffer)], { type: 'text/plain' }), 'UTF-8');
                }


                else if (/\.mp3$/i.test(filename) || /\.ogg$/i.test(filename) || /\.wav$/i.test(filename)) {
                    // Create a button for lazy loading the mini player
                    const loadPlayerButton = document.createElement('button');
                    loadPlayerButton.textContent = 'Load Player';
                    loadPlayerButton.className = 'load-player-btn';

                    // Event listener for button click
                    loadPlayerButton.addEventListener('click', function () {
                        // Create the mini audio player
                        const miniPlayer = createMiniAudioPlayer(filename, arrayBuffer);

                        // Replace the button with the mini player in the preview cell
                        previewCell.innerHTML = '';
                        previewCell.appendChild(miniPlayer);
                    });

                    // Append the button to the preview cell
                    previewCell.appendChild(loadPlayerButton);
                }

                // .dem
                else if (/\.(dem)$/i.test(filename)) {
                    const reader = new FileReader();
                    reader.onload = function (e) {
                        const fileText = e.target.result;
                        // Regular expression with negative lookahead to exclude specific patterns
                        const pattern = /maps\/(?!b_shell1|b_bh25|b_bh10|b_shell0|b_rock0|b_nail1|b_nail0|b_batt0|b_batt1|b_rock1|b_bh100|b_mrock0|b_mrock1|b_plas0|b_plas1|b_lnail0|b_lnail1)(.*?)\.bsp/g;
                        let match;
                        let matches = []; // Array to store matches

                        while ((match = pattern.exec(fileText)) !== null) {
                            matches.push(match[1]); // Store each match
                        }

                        if (matches.length === 0) {
                            previewCell.textContent = 'No matching "maps/*.bsp" pattern found in .dem file excluding specific cases';
                        } else {
                            // Determine singular or plural form based on the number of matches
                            let levelText = matches.length === 1 ? 'Map:' : 'Maps:';
                            // Join the matches with newline
                            let previewText = levelText + ' ' + matches.join(', ');
                            previewCell.textContent = previewText;
                        }
                    };
                    reader.readAsText(new Blob([new Uint8Array(arrayBuffer)], { type: 'text/plain' }), 'UTF-8');
                }

                // spr
                else if (/\.(spr)$/i.test(filename)) {
                    console.log(`Processing .spr file: ${filename}`);

                    const fileArrayBuffer = arrayBuffer;

                    if (fileArrayBuffer.byteLength !== fileSize) {
                        console.error(`File size mismatch for ${filename}: Expected ${fileSize}, but got ${fileArrayBuffer.byteLength}`);
                        continue;
                    }

                    if (fileArrayBuffer instanceof ArrayBuffer) {
                        // Use getFileObject to create an SPR object
                        var sprObject = QuakeWebTools.FileUtil.getFileObject("spr", filename, fileArrayBuffer);

                        // Check if sprObject is correctly formed
                        if (!sprObject) {
                            console.error(`Failed to create SPR object for ${filename}`);
                            continue;
                        }

                        // Assuming sprObject has a method to get image data (you might need to implement this)
                        var imageData = sprObject.getImageData();

                        // Check if imageData is correctly formed
                        if (!imageData || !imageData.length) {
                            console.error(`Failed to get image data for ${filename}`);
                            continue;
                        }

                        // Create a container element to hold the .spr preview
                        var previewContainer = document.createElement('div');
                        previewContainer.id = 'preview-container-' + i;
                        previewCell.appendChild(previewContainer);

                        // Generate the HTML preview inside the created container
                        QuakeWebTools.ImageUtil.generateHTMLPreviewSimple({
                            image_datas: imageData
                        }, QWT.DEFAULT_PALETTE, previewContainer.id);
                    } else {
                        console.error(`Failed to create ArrayBuffer for ${filename}`);
                    }
                }

                // lmp
                else if (/\.(lmp)$/i.test(filename)) {

                    const fileArrayBuffer = arrayBuffer;

                    if (fileArrayBuffer.byteLength !== fileSize) {
                        console.error(`File size mismatch for ${filename}: Expected ${fileSize}, but got ${fileArrayBuffer.byteLength}`);

                    }

                    if (fileArrayBuffer instanceof ArrayBuffer) {
                        console.log(`Buffer size for ${filename}: ${fileArrayBuffer.byteLength}`);

                        var justFileName = filename.split('/').pop();

                        // Now use justFileName to get the image data
                        var imageData = QWT.ImageUtil.getImageData(justFileName, fileArrayBuffer);

                        // Create a container element to hold the image preview
                        var previewContainer = document.createElement('div');
                        previewContainer.id = 'preview-container-' + i;
                        previewCell.appendChild(previewContainer);

                        // Generate the HTML preview inside the created container
                        QuakeWebTools.ImageUtil.generateHTMLPreviewSimple({
                            image_datas: [imageData]
                        }, QWT.DEFAULT_PALETTE, previewContainer.id);
                    } else {
                        console.error(`Failed to create ArrayBuffer for ${filename}`);
                    }
                }

                else if (/\.md3$/i.test(filename)) {
                    registerMd3Preview(previewCell, filename, arrayBuffer);
                }

                else if (/\.(mdl)$/i.test(filename)) {
                    console.log(`Processing .mdl file: ${filename}`);

                    const fileArrayBuffer = arrayBuffer;

                    const MAX_MDL_SIZE = 10000000; // Maximum reasonable size for .mdl file, adjust as needed
                    if (fileSize > MAX_MDL_SIZE) {
                        console.error(`File size exceeds the maximum expected size for .mdl file: ${filename}`);
                        previewCell.textContent = 'Error: File size exceeds maximum expected size.';
                        return; // Stop processing this file
                    }

                    try {
                        // Create MDL object from the file data
                        var mdl = new QuakeWebTools.MDL(filename, arrayBuffer);
                        var file_entry = G.FILEMANAGER.addFile(filename, fileArrayBuffer);

                        if (mdl.skins && mdl.skins.length > 0) {
                            // Iterate through each skin
                            mdl.skins.forEach((skin, skinIndex) => {
                                // Create a container element to hold the image preview for each skin
                                console.log(`Processing skin ${skinIndex}:`, skin); // Debug print for skin

                                var previewContainer = document.createElement('div');
                                previewContainer.id = `preview-container-${filename.replace(/[^a-zA-Z0-9]/g, '')}-skin-${skinIndex}`;
                                previewCell.appendChild(previewContainer);

                                // Prepare image data for preview
                                var imageData = {
                                    image_datas: [skin], // Pass the current skin object as image data
                                    image_infos: null,
                                    arraybuffer: null
                                };

                                // Generate the HTML preview inside the created container
                                QuakeWebTools.ImageUtil.generateHTMLPreviewSimple(imageData, QWT.DEFAULT_PALETTE, previewContainer.id);

                                var mdlview = file_entry.obj; // Get the MDL object from the FileManager
                                var currentSkinIndex = skinIndex;
                                // Assuming viewMDL2 is a function that takes the MDL object, the container ID, and the skin ID
                                QWT.ANIMATION_ID = viewMDL2(mdlview, previewContainer.id, currentSkinIndex); // Pass the container ID and skin ID


                            });
                        } else {
                            console.error(`No skins available for ${filename}`);
                            previewCell.textContent = 'Error: No skins available in file.';
                        }
                    } catch (error) {
                        console.error(`Error processing .mdl file: ${filename}`, error);
                        previewCell.textContent = 'Error processing file.';
                    }
                }

                else {
                    previewCell.textContent = '';
                }
            }
        }

        function readPackFile(file) {
            fileBlobs = [];
            viewFileBlobs = [];
            document.getElementById('loadingCircle').style.display = 'block';

            if (/\.pk3$/i.test(file.name)) {
                readPk3File(file);
                return;
            }

            const reader = new FileReader();

            reader.onload = function (e) {
                const buffer = e.target.result;
                const view = new DataView(buffer);

                const magic = new TextDecoder('utf-8').decode(new Uint8Array(buffer, 0, 4));
                if (magic !== 'PACK') {
                    alert('This is not a valid PAK file.');
                    document.getElementById('packfilecontents').innerHTML = '';
                    document.getElementById('downloadAll').style.display = 'none';
                    document.getElementById('loadingCircle').style.display = 'none';
                    return;
                }

                const diroffset = view.getUint32(4, true);
                const dirsize = view.getUint32(8, true);
                const numEntries = dirsize / 64;

                const contentsDiv = document.getElementById('packfilecontents');
                contentsDiv.innerHTML = '';

                const table = document.createElement('table');
                contentsDiv.appendChild(table);

                let crcDescription = '';

                const directoryBytes = new Uint8Array(buffer, diroffset, dirsize);
                const crc = crc16ccitt(directoryBytes);

                switch (crc) {
                    case 13900:
                        crcDescription = ' (Official PAK0 v. 1.0 - CRC-16-CCITT 13900)';
                        break;
                    case 62751:
                        crcDescription = ' (Official PAK0 v. 1.01 - CRC-16-CCITT 62751)';
                        break;
                    case 32981:
                        crcDescription = ' (Official PAK0 v. 1.06 - Steam - CRC-16-CCITT 32981)';
                        break;
                    case 60371:
                        crcDescription = ' (Official PAK0 Re-Release - Steam - CRC-16-CCITT 60371)';
                        break;
                    case 18139:
                        crcDescription = ' (Official PAK1 v. 1.01 - Steam - CRC-16-CCITT 18139)';
                        break;
                    case 42362:
                        crcDescription = ' (Official Scourge of Armagon [Hipnotic] - CRC-16-CCITT 42362)';
                        break;
                    case 19534:
                        crcDescription = ' (Official Dissolution of Eternity [Rogue] - CRC-16-CCITT 19534)';
                        break;
                    case 37050:
                        crcDescription = ' (Official Threewave CTF v. 3.01 - CRC-16-CCITT 37050)';
                        break;
                    case 46212:
                        crcDescription = ' (Official Threewave CTF v. 4.0 - CRC-16-CCITT 46212)';
                        break;
                    case 33258:
                        crcDescription = ' (Official League of Capture CTF v. 1.0 - CRC-16-CCITT 33258)';
                        break;
                    case 50532:
                        crcDescription = ' (Official Rocket Arena v. 1.2 - CRC-16-CCITT 50532)';
                        break;
                    case 46645:
                        crcDescription = ' (QTest ID1.PAK - CRC-16-CCITT 46645)';
                        break;
                }

                if (crc === 0xB635) {
                    crcDescription += ` | Files: ${numEntries}`;
                }

                const { hasPop, isPopCorrect } = checkPopLmp(view, diroffset, dirsize);
                let popCheck = '';
                if (hasPop) {
                    popCheck = ' | pop.lmp: Found, CRC: ' + (isPopCorrect ? 'Pass' : 'Fail');
                }

                const fileName = file.name;
                document.getElementById('viewing-text').innerHTML = '<span class="text-color-view-create">Viewing:</span> ' + fileName + crcDescription + popCheck;

                const entries = [];
                for (let i = 0; i < numEntries; i++) {
                    const entryOffset = diroffset + i * 64;
                    const filenameBytes = new Uint8Array(buffer, entryOffset, 56);
                    const entryName = new TextDecoder('utf-8').decode(filenameBytes).split('\0', 1)[0];
                    const fileOffset = view.getUint32(entryOffset + 56, true);
                    const fileSize = view.getUint32(entryOffset + 60, true);
                    const entryBuffer = buffer.slice(fileOffset, fileOffset + fileSize);
                    entries.push({
                        filename: entryName,
                        size: fileSize,
                        arrayBuffer: entryBuffer,
                        blob: new Blob([entryBuffer], { type: 'application/octet-stream' })
                    });
                }

                processFileEntries(entries, table);

                document.getElementById('downloadAll').style.display = entries.length > 0 ? 'inline-block' : 'none';
                document.getElementById('loadingCircle').style.display = 'none';
            };

            reader.onerror = function () {
                alert('Failed to read file.');
                document.getElementById('loadingCircle').style.display = 'none';
            };

            reader.readAsArrayBuffer(file);
        }

        async function readPk3File(file) {
            try {
                const contentsDiv = document.getElementById('packfilecontents');
                contentsDiv.innerHTML = '';

                const zip = await JSZip.loadAsync(file);
                const entryPromises = [];

                zip.forEach(function (relativePath, zipEntry) {
                    if (zipEntry.dir) {
                        return;
                    }
                    entryPromises.push(zipEntry.async('arraybuffer').then(function (arrayBuffer) {
                        return {
                            filename: relativePath,
                            size: arrayBuffer.byteLength,
                            arrayBuffer: arrayBuffer,
                            blob: new Blob([arrayBuffer], { type: 'application/octet-stream' })
                        };
                    }));
                });

                const entries = await Promise.all(entryPromises);
                entries.sort(function (a, b) {
                    return a.filename.localeCompare(b.filename, undefined, { sensitivity: 'base' });
                });

                document.getElementById('viewing-text').innerHTML = '<span class="text-color-view-create">Viewing:</span> ' + file.name + ' (PK3 archive, ' + entries.length + ' file' + (entries.length === 1 ? '' : 's') + ')';

                if (entries.length === 0) {
                    contentsDiv.textContent = 'No files found in this PK3.';
                    document.getElementById('downloadAll').style.display = 'none';
                    return;
                }

                const table = document.createElement('table');
                contentsDiv.appendChild(table);

                processFileEntries(entries, table);

                document.getElementById('downloadAll').style.display = 'inline-block';
            } catch (error) {
                console.error('Failed to read PK3 file:', error);
                alert('Unable to read PK3 file.');
                document.getElementById('packfilecontents').innerHTML = '';
                document.getElementById('downloadAll').style.display = 'none';
            } finally {
                document.getElementById('loadingCircle').style.display = 'none';
            }
        }
        document.getElementById('create_drop').addEventListener('click', function () {
            document.getElementById('pakcreator').click();
        });

        // Drag over event listener to add the hover effect
        document.getElementById('create_drop').addEventListener('dragover', function (event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'copy'; // Show as a copy cursor (optional)
            event.currentTarget.classList.add('hover'); // Add the hover class for visual feedback
        }, false);

        // Drag leave event listener to remove the hover effect
        document.getElementById('create_drop').addEventListener('dragleave', function (event) {
            event.currentTarget.classList.remove('hover'); // Remove the hover class when dragging leaves the drop zone
        }, false);

        async function handleDropForCreate(event) {
            event.preventDefault();
            event.stopPropagation();
            event.currentTarget.classList.remove('hover');

            const items = event.dataTransfer.items;
            let folderDropped = false;

            console.log("Drop event items:", items); // Debugging: Log the raw drop event items

            for (const item of items) {
                console.log("Handling item:", item); // Debugging: Log the item being handled
                if (item.kind === 'file') {
                    const entry = item.webkitGetAsEntry();
                    console.log("Entry:", entry); // Debugging: Log the entry

                    if (entry && entry.isDirectory) {
                        folderDropped = true;
                        const files = await readAllEntriesForCreate(entry.createReader());
                        createPakHelper(files, entry.name);
                        break;
                    } else if (entry && entry.isFile) {
                        // Handle file drop (optional, depending on your requirements)
                        console.log("File dropped:", entry); // Debugging: Log the file entry
                        // ... You may want to process individual file drops here ...
                    }
                }
            }

            if (!folderDropped) {
                console.error('No folder was dropped');
                alert('Please drop a folder');
            }
        }


        async function readAllEntriesForCreate(reader, parentPath = '') {
            let allEntries = [];
            let readEntries = async () => {
                let entries = await new Promise((resolve, reject) => reader.readEntries(resolve, reject));
                if (entries.length) {
                    allEntries.push(...entries);
                    await readEntries();
                }
            };
            await readEntries();

            let files = [];
            for (const entry of allEntries) {
                console.log("Entry:", entry, "Parent Path:", parentPath); // Debugging: Log each entry and its path

                if (entry.isFile) {
                    const file = await new Promise((resolve) => entry.file(resolve));
                    const relativePath = entry.fullPath.replace(/^\/[^\/]+\//, ''); // Remove the leading '/pak0/' (or similar) from the path
                    file.customPath = relativePath; // Use a custom property to store the relative path
                    console.log("Processed file:", file, "Custom Path:", file.customPath); // Debugging: Log the file and custom path
                    files.push(file);
                } else if (entry.isDirectory) {
                    const subdirectoryPath = entry.fullPath.replace(/^\//, '') + '/'; // Get the subdirectory path
                    files.push(...await readAllEntriesForCreate(entry.createReader(), subdirectoryPath));
                }
            }
            return files;
        }




        document.getElementById('create_drop').addEventListener('drop', handleDropForCreate, false);

        document.getElementById('pak_view_drop').addEventListener('click', function () {
            document.getElementById('packfile').click();
        });

        document.getElementById('pak_view_drop').addEventListener('dragover', function (event) {
            event.preventDefault();
            event.currentTarget.classList.add('hover');
        });

        document.getElementById('pak_view_drop').addEventListener('dragleave', function (event) {
            event.currentTarget.classList.remove('hover');
        });

        document.getElementById('pak_view_drop').addEventListener('drop', function (event) {
            event.preventDefault();
            event.currentTarget.classList.remove('hover');

            document.getElementById('loadingCircle').style.display = 'block';

            const files = event.dataTransfer.files;
            if (files.length === 0) {
                document.getElementById('loadingCircle').style.display = 'none';
                return;
            }

            const file = files[0]; // Considering only the first file for simplicity

            if (/(\.pak|\.pk3)$/i.test(file.name)) {
                pakSelector(files);
            } else {
                alert('Only .pak or .pk3 files are accepted');
                document.getElementById('loadingCircle').style.display = 'none';
                // Reset any changes made to the drop zone, if necessary
            }
        });

        document.getElementById('downloadAll').addEventListener('click', function () {
            const zip = new JSZip();
            const mainFolderName = viewCurrentPakFileName; // Use the PAK file name for the main folder's name

            viewFileBlobs.forEach(function (file) {
                // Prepend the main folder name to the file's path
                const filePath = mainFolderName + '/' + file.filename;
                zip.file(filePath, file.blob);
            });

            // Show the progress wrapper and reset the progress bar to 0%
            document.getElementById('progressWrapper').style.display = 'block';
            const progressBar = document.getElementById('progressBar');
            progressBar.style.width = '0%';
            progressBar.textContent = '0%';

            // Update the zip.generateAsync call to handle progress updates
            zip.generateAsync({ type: "blob" }, function (metadata) {
                // Update the progress bar with the current percentage
                const percent = metadata.percent.toFixed(2);
                progressBar.style.width = percent + '%';
                progressBar.textContent = percent + '%';
            }).then(function (content) {
                // Use the PAK file name for the zip file's name
                const url = URL.createObjectURL(content);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = mainFolderName + ".zip"; // Use the PAK file name here
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                setTimeout(() => URL.revokeObjectURL(url), 100);

                // Hide the progress bar when done
                document.getElementById('progressWrapper').style.display = 'none';
            }, function (err) {
                alert('Error generating zip: ' + err);
                // Hide the progress bar if there's an error
                document.getElementById('progressWrapper').style.display = 'none';
            });
        });

        // QWT Initation
        var QWT = QuakeWebTools;
        var G = QWT.GLOBAL;

        // will need a proper system to deal with these for multiple viewers
        if (QWT.ANIMATION_ID != null) {
            console.log("stopping animationFrame " + QWT.ANIMATION_ID);
            cancelAnimationFrame(QWT.ANIMATION_ID);
            QWT.ANIMATION_ID = null;
        }

    </script>
    <div id="footer">
        Created by <span class="bronze">w</span>ood<span class="bronze">s</span> &nbsp;&nbsp;| &nbsp;&nbsp;<a
            href="https://github.com/q1tools/q1tools.github.io"><i class="fa-brands fa-github"></i></a>
    </div>
</body>

</html>
