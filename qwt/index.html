<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">

    <title>Quake Web Tools</title>
    <link rel="icon" type="image/png" sizes="32x32" href="../favicon.png">
    <link rel="stylesheet" href="QuakeWebTools/css/style.css">

    <!--lib-->
    <script src="QuakeWebTools/scripts/lib/stats.min.js"></script>
    <script src="QuakeWebTools/scripts/lib/DataStream.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.6.0/jszip.min.js"></script>
    <script src="QuakeWebTools/scripts/lib/three.js"></script>
    <script src="QuakeWebTools/scripts/lib/orbitcontrols.js"></script>
    <script src="QuakeWebTools/scripts/lib/firstpersoncontrols.js"></script>
    <!--util-->
    <script src="QuakeWebTools/scripts/util/filemanager.js"></script>
    <script src="QuakeWebTools/scripts/util/fileutil.js"></script>
    <script src="QuakeWebTools/scripts/util/imageutil.js"></script>
    <!--types-->
    <script src="QuakeWebTools/scripts/types/pk3.js"></script>
    <script src="QuakeWebTools/scripts/types/pak.js"></script>
    <script src="QuakeWebTools/scripts/types/wad.js"></script>
    <script src="QuakeWebTools/scripts/types/pal.js"></script>
    <script src="QuakeWebTools/scripts/types/lmp.js"></script>
    <script src="QuakeWebTools/scripts/types/spr.js"></script>
    <script src="QuakeWebTools/scripts/types/bsp.js"></script>
    <script src="QuakeWebTools/scripts/types/mdl.js"></script>
    <script src="QuakeWebTools/scripts/types/md3.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tga-js@1.1.1/dist/umd/tga.js"></script>
    <!--application-->
    <script src="QuakeWebTools/scripts/quakewebtools.js"></script>
  </head>

  <body onload="app_init()" style="width: 540px">

    <article>
      <div id="holder" class="filedrop" style="min-height: 100px"
           aria-label="Drop files here">
        <h1 style="font-size: 2em">DROP FILES HERE</h1>
        <p>Drag Quake file format files (pak, pk3, wad, bsp, lmp, spr, mdl, md3, map,
        pal) into this area to load their content in your browser. For MD3
        models you can optionally drop matching PNG/JPG/TGA textures alongside the
        model. Prefer to pick files manually? Use the select button below.</p>
        <div id="file-content" class="" style="border:0">
        </div>
        <div id="loading-indicator" class="loading hidden" aria-live="polite">
          <p id="loading-message">Loading…</p>
          <div class="progress-bar" role="progressbar"
               aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
            <div id="loading-progress" class="progress-bar-fill"></div>
          </div>
        </div>
      </div> 
      <button id="file_select_button" type="button" class="file-select-button">
        Select files…
      </button>
      <p id="status">File API and FileReader API not supported</p>

      <!-- Hidden file input to support click-to-select -->
      <input id="file_input" type="file" style="display:none"
             multiple
             accept=".pak,.pk3,.wad,.bsp,.lmp,.spr,.mdl,.md3,.map,.pal,.png,.jpg,.jpeg,.tga" />
    </article>



  </body>
</html>



<!-- TODO: Clean up this mess and put it in a better location -->
<script>


// stats
if (0) {
  var stats = new Stats();
  stats.setMode(1); // 0: fps, 1: ms
  // Align top-left
  stats.domElement.style.position = 'absolute';
  stats.domElement.style.left = '0px';
  stats.domElement.style.top = '0px';
  document.body.appendChild( stats.domElement );
  QuakeWebTools.STATS = stats;
}

var holder = document.getElementById('holder');
var state = document.getElementById('status');
var fileInput = document.getElementById('file_input');
var fileSelectButton = document.getElementById('file_select_button');
var loadingIndicator = document.getElementById('loading-indicator');
var loadingMessage = document.getElementById('loading-message');
var loadingProgress = document.getElementById('loading-progress');
var loadingProgressBar = loadingIndicator ? loadingIndicator.querySelector('.progress-bar') : null;

if (typeof window.FileReader === 'undefined') {
  state.className = 'fail';
} else {
  state.parentNode.removeChild(state);
}

function clampProgress(value) {
  return Math.max(0, Math.min(100, Math.round(value)));
}

function formatFileSize(bytes) {
  if (typeof bytes !== "number" || !isFinite(bytes) || bytes < 0) return "";
  var units = ["B", "KB", "MB", "GB", "TB"];
  var index = 0;
  while (bytes >= 1024 && index < units.length - 1) {
    bytes /= 1024;
    index++;
  }
  var value = index === 0 ? Math.round(bytes) : bytes.toFixed(1);
  return value + " " + units[index];
}

function showLoadingIndicator(message) {
  if (!loadingIndicator || !loadingProgressBar || !loadingMessage || !loadingProgress) return;
  loadingIndicator.classList.remove('hidden');
  loadingProgressBar.classList.remove('indeterminate');
  loadingProgress.style.width = '0%';
  loadingProgressBar.setAttribute('aria-valuenow', '0');
  loadingProgressBar.removeAttribute('aria-valuetext');
  loadingMessage.textContent = message;
}

function updateDeterminateProgress(percent, message) {
  if (!loadingIndicator || !loadingProgressBar || !loadingMessage || !loadingProgress) return;
  var clamped = clampProgress(percent);
  loadingProgressBar.classList.remove('indeterminate');
  loadingProgress.style.width = clamped + '%';
  loadingProgressBar.setAttribute('aria-valuenow', String(clamped));
  loadingProgressBar.removeAttribute('aria-valuetext');
  if (message) loadingMessage.textContent = message;
}

function updateIndeterminateProgress(message) {
  if (!loadingIndicator || !loadingProgressBar || !loadingMessage || !loadingProgress) return;
  loadingProgressBar.classList.add('indeterminate');
  loadingProgress.style.width = '40%';
  loadingProgressBar.removeAttribute('aria-valuenow');
  loadingProgressBar.setAttribute('aria-valuetext', 'Loading');
  if (message) loadingMessage.textContent = message;
}

function hideLoadingIndicator() {
  if (!loadingIndicator || !loadingProgressBar || !loadingMessage || !loadingProgress) return;
  loadingIndicator.classList.add('hidden');
  loadingProgressBar.classList.remove('indeterminate');
  loadingProgress.style.width = '0%';
  loadingProgressBar.setAttribute('aria-valuenow', '0');
  loadingProgressBar.removeAttribute('aria-valuetext');
  loadingMessage.textContent = 'Loading…';
}

function isTextureExtension(type) {
  if (!type) return false;
  return type === 'png' || type === 'jpg' || type === 'jpeg' || type === 'tga';
}

function processFileList(fileList) {
  var files = Array.from(fileList || []);
  if (!files.length) return;
  var textures = [];
  var others = [];
  files.forEach(function (file) {
    if (!file || !file.name) {
      others.push(file);
      return;
    }
    var dot = file.name.lastIndexOf('.');
    var ext = dot !== -1 ? file.name.substring(dot + 1).toLowerCase() : '';
    if (isTextureExtension(ext)) {
      textures.push(file);
    } else {
      others.push(file);
    }
  });
  others.concat(textures).forEach(handleFile);
}

function teardownActiveViewer() {
  var QWT = QuakeWebTools;
  if (QWT.ANIMATION_ID != null) {
    console.log("stopping animationFrame " + QWT.ANIMATION_ID);
    cancelAnimationFrame(QWT.ANIMATION_ID);
    QWT.ANIMATION_ID = null;
  }
  var G = QWT.GLOBAL;
  if (G && G.ACTIVE_MD3_VIEWER && typeof G.ACTIVE_MD3_VIEWER.dispose === "function") {
    G.ACTIVE_MD3_VIEWER.dispose();
  }
  if (G) {
    G.ACTIVE_MD3_VIEWER = null;
  }
}

function queueOrApplyMd3Texture(file) {
  if (!file) return;
  var ext = "";
  if (file.name) {
    var dotIndex = file.name.lastIndexOf(".");
    ext = dotIndex !== -1 ? file.name.substring(dotIndex + 1).toLowerCase() : "";
  }

  if (ext === "tga") {
    console.log("[QWT][MD3] Converting TGA texture:", file.name);
    convertTgaFileToDataUrl(file)
      .then(function(dataUrl) {
        console.log("[QWT][MD3] TGA conversion result length:", dataUrl && dataUrl.length);
        var convertedFile = createPngFileFromDataUrl(file, dataUrl);
        if (!convertedFile) {
          throw new Error("Unable to create PNG texture from data URL");
        }
        console.log("[QWT][MD3] TGA converted to PNG blob:", convertedFile.name);
        applyOrQueueMd3TextureFile(convertedFile);
      })
      .catch(function(err) {
        console.error("[QWT][MD3] Failed to convert TGA texture:", err);
        alert("Unable to convert texture '" + file.name + "'. Check the console for details.");
      });
    return;
  }

  applyOrQueueMd3TextureFile(file);
}

function applyOrQueueMd3TextureFile(file) {
  var QWT = QuakeWebTools;
  var G = QWT.GLOBAL;
  if (G && G.ACTIVE_MD3_VIEWER && typeof G.ACTIVE_MD3_VIEWER.loadTextureFromFile === "function") {
    console.log("[QWT][MD3] Applying dropped texture immediately:", file && file.name);
    G.ACTIVE_MD3_VIEWER.loadTextureFromFile(file);
    // Keep as pending so subsequent MD3 loads (in same multi-drop) also get it.
    G.PENDING_MD3_TEXTURE = file;
  } else if (G) {
    console.log("[QWT][MD3] Queuing texture until MD3 loads:", file && file.name);
    G.PENDING_MD3_TEXTURE = file;
  }
}

function convertTgaFileToDataUrl(file) {
  return new Promise(function(resolve, reject) {
    if (typeof TgaLoader !== "function") {
      reject(new Error("TgaLoader dependency not available"));
      return;
    }
    var reader = new FileReader();
    reader.onload = function(event) {
      try {
        var loader = new TgaLoader();
        loader.load(new Uint8Array(event.target.result));
        var canvas = loader.getCanvas();
        if (!canvas) {
          throw new Error("TGA conversion failed: no canvas produced");
        }
        resolve(canvas.toDataURL("image/png"));
      } catch (err) {
        reject(err);
      }
    };
    reader.onerror = function(err) {
      reject(err);
    };
    reader.readAsArrayBuffer(file);
  });
}

function createPngFileFromDataUrl(originalFile, dataUrl) {
  if (!dataUrl) return null;
  var blob;
  try {
    blob = dataUrlToBlob(dataUrl);
  } catch (err) {
    console.error("[QWT][MD3] Failed to convert data URL to blob:", err);
    return null;
  }
  var filename = originalFile && originalFile.name ? originalFile.name.replace(/\.tga$/i, ".png") : "texture.png";
  var fileLike = null;
  if (typeof File === "function") {
    try {
      fileLike = new File([blob], filename, { type: blob.type || "image/png" });
    } catch (err) {
      console.warn("[QWT][MD3] Unable to create File from blob, falling back to plain object:", err);
    }
  }
  if (!fileLike) {
    fileLike = {
      name: filename,
      type: blob.type || "image/png"
    };
  }
  fileLike.dataUrl = dataUrl;
  fileLike.originalName = originalFile && originalFile.name ? originalFile.name : filename;
  fileLike._blob = blob;
  return fileLike;
}

function dataUrlToBlob(dataUrl) {
  var parts = String(dataUrl).split(",");
  if (parts.length < 2) {
    throw new Error("Invalid data URL");
  }
  var header = parts[0];
  var base64Data = parts[1];
  var mimeMatch = header.match(/data:(.*?)(;base64)?$/i);
  var mimeType = mimeMatch && mimeMatch[1] ? mimeMatch[1] : "image/png";
  var binary = atob(base64Data);
  var len = binary.length;
  var bytes = new Uint8Array(len);
  for (var i = 0; i < len; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return new Blob([bytes], { type: mimeType });
}

// Shared file handler used by both drag-drop and picker
function handleFile(file) {
  if (!file) return;
  var ext = "";
  if (file.name) {
    var dot = file.name.lastIndexOf(".");
    ext = dot !== -1 ? file.name.substring(dot + 1).toLowerCase() : "";
  }
  if (isTextureExtension(ext)) {
    queueOrApplyMd3Texture(file);
    return;
  }
  var reader = new FileReader();

  reader.onloadstart = function () {
    showLoadingIndicator("Loading " + file.name + "…");
  };

  reader.onprogress = function (event) {
    if (!event.lengthComputable) {
      updateIndeterminateProgress("Loading " + file.name + "…");
      return;
    }
    var percentLoaded = event.total > 0 ? (event.loaded / event.total) * 100 : 100;
    updateDeterminateProgress(percentLoaded, "Loading " + file.name + "… (" + clampProgress(percentLoaded) + "%)");
  };

  reader.onerror = function (event) {
    console.error("Error reading file:", file.name, event);
    hideLoadingIndicator();
    alert("Unable to read " + file.name + ". Please try again.");
  };

  reader.onload = async function (event) {
    updateIndeterminateProgress("Processing " + file.name + "…");
    var QWT = QuakeWebTools;
    var G = QWT.GLOBAL;

    try {
      var file_entry = G.FILEMANAGER.addFile(file.name, event.target.result);
      var filename = file_entry.path;
      var arraybuffer = file_entry.data;
      var type = file_entry.type || "";
      var isTexture = isTextureExtension(type);

      if (!isTexture) {
        teardownActiveViewer();
        document.getElementById("file-content").innerHTML = "";
      }

      switch (type) {
        case "pk3":
          await viewPK3(file_entry.obj);
          break;
        case "pak":
          viewPAK(file_entry.obj);
          break;
        case "wad":
          QWT.ImageUtil.generateHTMLPreview({image_infos: file_entry.obj.directory, arraybuffer: file_entry.obj.ab},
            QWT.DEFAULT_PALETTE, "file-content");
          break;
        case "bsp":
          QWT.ANIMATION_ID = viewBSP(file_entry.obj);
          QWT.ImageUtil.generateHTMLPreview({image_infos: file_entry.obj.miptex_directory, arraybuffer: file_entry.obj.ab},
            QWT.DEFAULT_PALETTE, "file-content");
          break;
        case "spr":
          QWT.ImageUtil.generateHTMLPreview({image_datas: file_entry.obj.getImageData()},
            QWT.DEFAULT_PALETTE, "file-content");
          break;
        case "lmp":
        case "pal":
          QWT.ImageUtil.generateHTMLPreview({image_datas: [QWT.ImageUtil.getImageData(filename, arraybuffer)]},
            QWT.DEFAULT_PALETTE, "file-content");
          break;
        case "mdl":
          QWT.ANIMATION_ID = viewMDL(file_entry.obj);
          QWT.ImageUtil.generateHTMLPreview({image_datas: file_entry.obj.skins}, QWT.DEFAULT_PALETTE, "file-content");
          break;
        case "md3":
          console.log("[QWT][MD3] Creating viewer for:", filename, "pending texture:", (G.PENDING_MD3_TEXTURE && G.PENDING_MD3_TEXTURE.name) || "<none>");
          var viewer = viewMD3(file_entry.obj);
          QWT.ANIMATION_ID = viewer.animationId;
          G.ACTIVE_MD3_VIEWER = viewer;
          try { console.log('[QWT][MD3] viewer.loadTextureFromFile typeof =', typeof viewer.loadTextureFromFile); } catch (e) {}
          if (G.PENDING_MD3_TEXTURE) {
            console.log("[QWT][MD3] Applying pending texture to new viewer:", G.PENDING_MD3_TEXTURE.name);
            try {
              viewer.loadTextureFromFile(G.PENDING_MD3_TEXTURE);
            } catch (e) {
              console.warn("[QWT][MD3] Failed to apply pending texture:", e);
            }
            // Do NOT clear pending; allow subsequent MD3s (same drop) to reuse it.
          }
          break;
        default:
          alert("File type not supported (" + type + ")");
      }
    } catch (err) {
      console.error("Failed to process file:", file.name, err);
      alert("Failed to process " + file.name + ". Check the developer console for details.");
    } finally {
      hideLoadingIndicator();
    }
  };

  reader.readAsArrayBuffer(file);
}

holder.ondragover = function () { this.className = 'filedrop-hover'; return false; };
holder.ondragleave = function () { this.className = 'filedrop'; return false; };
holder.ondragend = holder.ondragleave;
holder.ondrop = function (e) {
  this.className = 'filedrop';
  e.preventDefault();
  // Support multiple file drops
  processFileList(e.dataTransfer.files);
  return false;
};

// Manual file selection button
if (fileSelectButton) {
  fileSelectButton.addEventListener('click', function () {
    fileInput && fileInput.click();
  });
}

// Picker ? process selected files
fileInput.addEventListener('change', function (e) {
  processFileList(e.target.files || []);
  // reset so selecting the same file again still triggers change
  e.target.value = '';
});

</script>
